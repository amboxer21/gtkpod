diff --git a/TODO.gsettings b/TODO.gsettings
new file mode 100644
index 0000000..74747c1
--- /dev/null
+++ b/TODO.gsettings
@@ -0,0 +1,4 @@
+default values for path/track naming
+default value for SJ_SETTINGS_BASE_URI (sj_get_default_music_directory())
+audio profiles still using gconf ?
+bind_window_size
diff --git a/configure.in b/configure.in
index 37a85df..f65d852 100644
--- a/configure.in
+++ b/configure.in
@@ -33,6 +33,7 @@ GNOME_DEBUG_CHECK
 GNOME_MAINTAINER_MODE_DEFINES
 
 GTK_REQUIRED=2.90.0
+GLIB_GSETTINGS
 
 AC_CHECK_FUNC(socket,,[AC_CHECK_LIB(socket,socket)])
 
@@ -40,7 +41,7 @@ AC_CHECK_FUNC(socket,,[AC_CHECK_LIB(socket,socket)])
 GNOME_DOC_INIT
 
 # Find GLib and GObject
-PKG_CHECK_MODULES(GLIB, glib-2.0 >= 2.18 gthread-2.0 gobject-2.0)
+PKG_CHECK_MODULES(GLIB, glib-2.0 >= 2.18 gthread-2.0 gobject-2.0 gio-2.0)
 AC_SUBST(GLIB_CFLAGS)
 AC_SUBST(GLIB_LIBS)
 
@@ -56,11 +57,11 @@ LIBS="$LIBS $BURN_LIBS"
 # LIBS="$oldlibs"
 
 # Find the UI libraries
-PKG_CHECK_MODULES(UI, gtk+-3.0 >= $GTK_REQUIRED gconf-2.0 gio-2.0 gmodule-export-2.0 dbus-glib-1 libcanberra-gtk3)
+PKG_CHECK_MODULES(UI, gtk+-3.0 >= $GTK_REQUIRED gio-2.0 gmodule-export-2.0 dbus-glib-1 libcanberra-gtk3)
 AC_SUBST(UI_CFLAGS)
 AC_SUBST(UI_LIBS)
 
-PKG_CHECK_MODULES(GSTREAMER, gstreamer-0.10 >= 0.10.15 gstreamer-plugins-base-0.10)
+PKG_CHECK_MODULES(GSTREAMER, gstreamer-0.10 >= 0.10.32 gstreamer-plugins-base-0.10 gstreamer-pbutils-0.10)
 AC_SUBST(GSTREAMER_CFLAGS)
 AC_SUBST(GSTREAMER_LIBS)
 
@@ -70,11 +71,6 @@ AM_GST_ELEMENT_CHECK(flacenc,,AC_MSG_WARN([The 'flacenc' element was not found.
 AM_GST_ELEMENT_CHECK(wavenc,,AC_MSG_WARN([The 'wavenc' element was not found. This will cause encoding to Wave to fail.]))
 AM_GST_ELEMENT_CHECK(giosink,,AC_MSG_WARN([The 'giosink' element was not found. This will cause Sound Juicer to fail at runtime.]))
 
-# Find GNOME Media Profiles
-PKG_CHECK_MODULES(MEDIA_PROFILES, libgnome-media-profiles-3.0)
-AC_SUBST(MEDIA_PROFILES_CFLAGS)
-AC_SUBST(MEDIA_PROFILES_LIBS)
-
 # Find required MusicBrainz3
 PKG_CHECK_MODULES(MUSICBRAINZ3, libmusicbrainz3 >= 3.0.2, [have_mb3=yes], [have_mb3=no])
 AC_SUBST(MUSICBRAINZ3_CFLAGS)
@@ -100,14 +96,6 @@ PKG_CHECK_MODULES(DBUS, dbus-1)
 AC_SUBST(DBUS_CFLAGS)
 AC_SUBST(DBUS_LIBS)
 
-# Find how and where to put the GConf schemas
-AC_PATH_PROG(GCONFTOOL, gconftool-2, no)
-if test "$GCONFTOOL" = "no"; then
-        AC_MSG_ERROR([gconftool-2 executable not found in your path - should be installed with GConf])
-fi
-AM_GCONF_SOURCE_2
-
-
 # Optionally enable G* deprecations
 AC_MSG_CHECKING([whether to enable deprecation warnings])
 AC_ARG_ENABLE([deprecations],
diff --git a/data/Makefile.am b/data/Makefile.am
index b2a3f58..b753c23 100644
--- a/data/Makefile.am
+++ b/data/Makefile.am
@@ -6,10 +6,12 @@ desktop_in_files = sound-juicer.desktop.in.in
 desktop_DATA = $(desktop_in_files:.desktop.in.in=.desktop)
 @INTLTOOL_DESKTOP_RULE@
 
-schemadir = $(GCONF_SCHEMA_FILE_DIR)
-schema_in_files = sound-juicer.schemas.in
-schema_DATA = $(schema_in_files:.schemas.in=.schemas)
-@INTLTOOL_SCHEMAS_RULE@
+profilesdir = $(datadir)/sound-juicer
+profiles_DATA = rhythmbox.gep
+
+gsettings_SCHEMAS = org.gnome.SoundJuicer.gschema.xml
+@GSETTINGS_RULES@
+
 
 man1_MANS = sound-juicer.1
 
@@ -56,25 +58,13 @@ uninstall-icons:
 	done
 
 install-data-local: install-icons
-if GCONF_SCHEMAS_INSTALL
-	@if test -z "$(DESTDIR)" ; then \
-		for p in $(schema_DATA) ; do \
-			GCONF_CONFIG_SOURCE=$(GCONF_SCHEMA_CONFIG_SOURCE) $(GCONFTOOL) --makefile-install-rule $$p 2>&1 > /dev/null; \
-		done \
-	fi ||  (echo ;\
-                echo "*****************************************************"; \
-                echo "Installation of schemas failed, install them manually"; \
-                echo "*****************************************************";)
-	@true
-endif
 
 uninstall-local: uninstall-icons
 
 CLEANFILES = \
-	$(desktop_DATA) \
-	$(schema_DATA)
+	$(desktop_DATA)
 
 EXTRA_DIST = \
-	$(schema_in_files) \
+	$(gsettings_SCHEMAS) \
 	$(man1_MANS) \
 	$(icons)
diff --git a/data/org.gnome.SoundJuicer.gschema.xml b/data/org.gnome.SoundJuicer.gschema.xml
new file mode 100644
index 0000000..461abff
--- /dev/null
+++ b/data/org.gnome.SoundJuicer.gschema.xml
@@ -0,0 +1,59 @@
+<?xml version="1.0"?>
+<schemalist>
+  <schema id="org.gnome.SoundJuicer" path="/apps/sound-juicer/">
+    <key name="device" type="s">
+      <default>''</default>
+      <summary>The CD to extract from.</summary>
+    </key>
+    <key name="eject" type="b">
+      <default>false</default>
+      <summary>Whether to eject the CD when finished extracting.</summary>
+    </key>
+    <key name="open-completed" type="b">
+      <default>false</default>
+      <summary>Whether to open the target directory when finished extracting.</summary>
+    </key>
+    <key name="base-uri" type="s">
+      <default>''</default>
+      <summary>The URI to save the extracted music to.</summary>
+    </key>
+    <key name="base-path" type="s">
+      <default>''</default>
+      <summary>The local directory to save the extracted music to (deprecated, use base_uri)</summary>
+    </key>
+    <key name="path-pattern" type="s">
+      <default>'%aa/%at'</default>
+      <summary>The directory structure for the files</summary>
+      <description>%at -- album title %aT -- album title (lowercase) %aa -- album artist %aA -- album artist (lowercase) %as -- album artist (sortable) %aS -- album artist (sortable lowercase) %ay -- album year %tt -- track title %tT -- track title (lowercase) %ta -- track artist %tA -- track artist (lowercase) %ts -- track artist (sortable) %tS -- track artist (sortable lowercase)</description>
+    </key>
+    <key name="file-pattern" type="s">
+      <default>'%dn - %tt'</default>
+      <summary>The name pattern for files</summary>
+      <description>Do not specify an extension. %at -- album title %aT -- album title (lowercase) %aa -- album artist %aA -- album artist (lowercase) %as -- album artist (sortable) %aS -- album artist (sortable lowercase) %tn -- track number (i.e 8) %tN -- track number, zero padded (i.e 08) %tt -- track title %tT -- track title (lowercase) %ta -- track artist %tA -- track artist (lowercase) %ts -- track artist (sortable) %tS -- track artist (sortable lowercase) %dn -- disc and track number (i.e Disk 2 - 6, or 6) %dN -- disc number, zero padded (i.e d02t06, or 06)</description>
+    </key>
+    <key name="paranoia" type="i">
+      <default>8</default>
+      <summary>The paranoia mode to use</summary>
+      <description>Paranoia mode: 0) disable 2) fragment 4) overlap 8) scratch 16) repair 255) full</description>
+    </key>
+    <key name="strip-special" type="b">
+      <default>false</default>
+      <summary>If to strip special characters from filenames</summary>
+      <description>If enabled, special characters such as space, wildcards and backslashes will be removed from the output filename.</description>
+    </key>
+    <key name="musicbrainz-server" type="s">
+      <default>''</default>
+      <summary>The MusicBrainz server to use</summary>
+      <description>If specified, this value will override the default MusicBrainz server.</description>
+    </key>
+    <key name="audio-profile" type="s">
+      <default>'audio/x-vorbis'</default>
+      <summary>Media type to encode to</summary>
+      <description>The GStreamer media type to encode to.</description>
+    </key>
+    <key name="volume" type="d">
+      <default>1.0</default>
+      <summary>Audio volume</summary>
+    </key>
+  </schema>
+</schemalist>
diff --git a/data/rhythmbox.gep b/data/rhythmbox.gep
new file mode 100644
index 0000000..6383d96
--- /dev/null
+++ b/data/rhythmbox.gep
@@ -0,0 +1,46 @@
+[GStreamer Encoding Target]
+name = rhythmbox
+category = muh
+description = Common encoding profiles for Rhythmbox
+
+[profile-mp3]
+name = mp3
+description = MPEG Layer 3 Audio
+format = application/x-id3
+type = container
+
+[streamprofile-mp3-1]
+parent = mp3
+type = audio
+format = audio/mpeg, mpegversion=1, layer=3
+presence = 1
+
+[profile-oggvorbis]
+name = oggvorbis
+description = Ogg Vorbis
+format = application/ogg
+type = container
+
+[streamprofile-oggvorbis-1]
+parent = oggvorbis
+type = audio
+format = audio/x-vorbis
+presence = 1
+
+[profile-flac]
+name = flac
+description = FLAC
+format = audio/x-flac
+type = audio
+
+[profile-m4a]
+name = m4a
+description = MPEG 4 Audio
+format = video/quicktime, variant=iso
+type = container
+
+[streamprofile-m4a-1]
+parent = m4a
+type = audio
+format = audio/mpeg, mpegversion=4, stream-format=raw
+presence = 1
diff --git a/data/sound-juicer.schemas.in b/data/sound-juicer.schemas.in
deleted file mode 100644
index 145bbb2..0000000
--- a/data/sound-juicer.schemas.in
+++ /dev/null
@@ -1,187 +0,0 @@
-<?xml version="1.0"?>
-
-<gconfschemafile>
-  <schemalist>
-
-    <schema>
-      <key>/schemas/apps/sound-juicer/device</key>
-      <applyto>/apps/sound-juicer/device</applyto>
-      <type>string</type>
-      <owner>sound-juicer</owner>
-      <locale name="C">
-        <!-- No default, NULL will query the machine -->
-        <short>The CD to extract from.</short>
-      </locale>
-    </schema>
-
-    <schema>
-      <key>/schemas/apps/sound-juicer/eject</key>
-      <applyto>/apps/sound-juicer/eject</applyto>
-      <type>bool</type>
-      <owner>sound-juicer</owner>
-      <default>false</default>
-      <locale name="C">
-        <short>Whether to eject the CD when finished extracting.</short>
-      </locale>
-    </schema>
-
-    <schema>
-      <key>/schemas/apps/sound-juicer/open_completed</key>
-      <applyto>/apps/sound-juicer/open_completed</applyto>
-      <type>bool</type>
-      <owner>sound-juicer</owner>
-      <default>false</default>
-      <locale name="C">
-        <short>Whether to open the target directory when finished extracting.</short>
-      </locale>
-    </schema>
-
-    <schema>
-      <key>/schemas/apps/sound-juicer/base_uri</key>
-      <applyto>/apps/sound-juicer/base_uri</applyto>
-      <type>string</type>
-      <owner>sound-juicer</owner>
-      <locale name="C">
-        <!-- No default, NULL will use $HOME -->
-        <short>The URI to save the extracted music to.</short>
-      </locale>
-    </schema>
-
-    <schema>
-      <key>/schemas/apps/sound-juicer/base_path</key>
-      <applyto>/apps/sound-juicer/base_path</applyto>
-      <type>string</type>
-      <owner>sound-juicer</owner>
-      <locale name="C">
-        <!-- No default, NULL will use $HOME -->
-        <short>The local directory to save the extracted music to (deprecated, use base_uri)</short>
-      </locale>
-    </schema>
-
-    <schema>
-      <key>/schemas/apps/sound-juicer/path_pattern</key>
-      <applyto>/apps/sound-juicer/path_pattern</applyto>
-      <type>string</type>
-      <owner>sound-juicer</owner>
-      <default>%aa/%at</default>
-      <locale name="C">
-        <short>The directory structure for the files</short>
-        <long>
-        %at -- album title
-        %aT -- album title (lowercase)
-        %aa -- album artist
-        %aA -- album artist (lowercase)
-        %as -- album artist (sortable)
-        %aS -- album artist (sortable lowercase)
-        %ay -- album year
-        %tt -- track title
-        %tT -- track title (lowercase)
-        %ta -- track artist
-        %tA -- track artist (lowercase)
-        %ts -- track artist (sortable)
-        %tS -- track artist (sortable lowercase)
-        </long>
-      </locale>
-    </schema>
-
-    <schema>
-      <key>/schemas/apps/sound-juicer/file_pattern</key>
-      <applyto>/apps/sound-juicer/file_pattern</applyto>
-      <type>string</type>
-      <owner>sound-juicer</owner>
-      <default>%dn - %tt</default>
-      <locale name="C">
-        <short>The name pattern for files</short>
-        <long>
-        Do not specify an extension.
-        %at -- album title
-        %aT -- album title (lowercase)
-        %aa -- album artist
-        %aA -- album artist (lowercase)
-        %as -- album artist (sortable)
-        %aS -- album artist (sortable lowercase)
-        %tn -- track number (i.e 8)
-        %tN -- track number, zero padded (i.e 08)
-        %tt -- track title
-        %tT -- track title (lowercase)
-        %ta -- track artist
-        %tA -- track artist (lowercase)
-        %ts -- track artist (sortable)
-        %tS -- track artist (sortable lowercase)
-        %dn -- disc and track number (i.e Disk 2 - 6, or 6)
-        %dN -- disc number, zero padded (i.e d02t06, or 06)
-        </long>
-      </locale>
-    </schema>
-
-    <schema>
-      <key>/schemas/apps/sound-juicer/paranoia</key>
-      <applyto>/apps/sound-juicer/paranoia</applyto>
-      <type>int</type>
-      <owner>sound-juicer</owner>
-      <default>8</default>
-      <locale name="C">
-        <short>The paranoia mode to use</short>
-        <long>
-          Paranoia mode: 0) disable 2) fragment 4) overlap 8) scratch 16) repair 255) full
-        </long>
-      </locale>
-    </schema>
-
-    <schema>
-      <key>/schemas/apps/sound-juicer/strip-special</key>
-      <applyto>/apps/sound-juicer/strip-special</applyto>
-      <type>bool</type>
-      <owner>sound-juicer</owner>
-      <default>false</default>
-      <locale name="C">
-        <short>If to strip special characters from filenames</short>
-        <long>
-          If enabled, special characters such as space, wildcards and
-          backslashes will be removed from the output filename.
-        </long>
-      </locale>
-    </schema>
-
-    <schema>
-      <key>/schemas/apps/sound-juicer/musicbrainz_server</key>
-      <applyto>/apps/sound-juicer/musicbrainz_server</applyto>
-      <type>string</type>
-      <owner>sound-juicer</owner>
-      <!-- No default, NULL will use library default -->
-      <locale name="C">
-        <short>The MusicBrainz server to use</short>
-        <long>
-          If specified, this value will override the default MusicBrainz
-          server.
-        </long>
-      </locale>
-    </schema>
-
-    <schema>
-      <key>/schemas/apps/sound-juicer/audio_profile</key>
-      <applyto>/apps/sound-juicer/audio_profile</applyto>
-      <type>string</type>
-      <owner>sound-juicer</owner>
-      <default>cdlossy</default>
-      <locale name="C">
-        <short>Audio Profile with which to encode</short>
-        <long>
-          The GNOME Audio Profile with which to encode.
-        </long>
-      </locale>
-    </schema>
-
-    <schema>
-      <key>/schemas/apps/sound-juicer/volume</key>
-      <applyto>/apps/sound-juicer/volume</applyto>
-      <type>float</type>
-      <owner>sound-juicer</owner>
-      <default>1.0</default>
-      <locale name="C">
-        <short>Audio volume</short>
-      </locale>
-    </schema>
-
-  </schemalist>
-</gconfschemafile>
diff --git a/data/sound-juicer.ui b/data/sound-juicer.ui
index 2625f97..d2ddf28 100644
--- a/data/sound-juicer.ui
+++ b/data/sound-juicer.ui
@@ -1125,6 +1125,7 @@ audio-volume-medium</property>
                             </child>
                             <child>
                               <object class="GtkButton" id="prefs_edit_profile">
+                                <property name="sensitive">False</property>
                                 <property name="can_focus">True</property>
                                 <property name="receives_default">False</property>
                                 <signal name="clicked" handler="prefs_edit_profile_clicked"/>
diff --git a/libjuicer/Makefile.am b/libjuicer/Makefile.am
index 9844ad6..d87e755 100644
--- a/libjuicer/Makefile.am
+++ b/libjuicer/Makefile.am
@@ -2,6 +2,8 @@ noinst_LTLIBRARIES = libjuicer.la
 
 libjuicer_la_SOURCES = \
 	$(MARSHALFILES) \
+	rb-gst-media-types.h \
+	rb-gst-media-types.c \
 	sj-structures.h \
 	sj-structures.c \
 	sj-error.h sj-error.c \
@@ -16,6 +18,7 @@ libjuicer_la_SOURCES = \
 	sj-util.h sj-util.c
 
 libjuicer_la_CPPFLAGS = \
+	-DDATADIR=\""$(datadir)"\" \
 	$(DISABLE_DEPRECATED_CFLAGS) \
 	$(AM_CPPFLAGS)
 
@@ -23,7 +26,6 @@ libjuicer_la_CFLAGS = \
 	$(WARN_CFLAGS)	\
 	$(MUSICBRAINZ3_CFLAGS) \
 	$(GSTREAMER_CFLAGS) \
-	$(MEDIA_PROFILES_CFLAGS) \
 	$(BURN_CFLAGS) \
 	$(UI_CFLAGS) \
 	$(CDIO_CFLAGS) \
@@ -31,7 +33,6 @@ libjuicer_la_CFLAGS = \
 
 libjuicer_la_LIBADD = \
 	$(MUSICBRAINZ3_LIBS) \
-	$(MEDIA_PROFILES_LIBS) \
 	$(GSTREAMER_LIBS) \
 	$(BURN_LIBS) \
 	$(UI_LIBS) \
diff --git a/libjuicer/rb-gst-media-types.c b/libjuicer/rb-gst-media-types.c
new file mode 100644
index 0000000..e87b013
--- /dev/null
+++ b/libjuicer/rb-gst-media-types.c
@@ -0,0 +1,336 @@
+/*
+ *  Copyright (C) 2010  Jonathan Matthew  <jonathan@d14n.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  The Rhythmbox authors hereby grant permission for non-GPL compatible
+ *  GStreamer plugins to be used and distributed together with GStreamer
+ *  and Rhythmbox. This permission is above and beyond the permissions granted
+ *  by the GPL license by which Rhythmbox is covered. If you modify this code
+ *  you may extend this exception to your version of the code, but you are not
+ *  obligated to do so. If you do not wish to do so, delete this exception
+ *  statement from your version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA.
+ *
+ */
+
+#include "config.h"
+
+#include <memory.h>
+
+#include <gst/pbutils/encoding-target.h>
+#include <gst/pbutils/missing-plugins.h>
+
+#include "rb-gst-media-types.h"
+
+#define SOURCE_ENCODING_TARGET_FILE "../data/rhythmbox.gep"
+#define INSTALLED_ENCODING_TARGET_FILE DATADIR"/sound-juicer/rhythmbox.gep"
+static GstEncodingTarget *default_target = NULL;
+
+char *
+rb_gst_caps_to_media_type (const GstCaps *caps)
+{
+	GstStructure *s;
+	const char *media_type;
+
+	/* the aim here is to reduce the caps to a single mimetype-like
+	 * string, describing the audio encoding (for audio files) or the
+	 * file type (for everything else).  raw media types are ignored.
+	 *
+	 * there are only a couple of special cases.
+	 */
+
+	if (gst_caps_get_size (caps) == 0)
+		return NULL;
+
+	s = gst_caps_get_structure (caps, 0);
+	media_type = gst_structure_get_name (s);
+	if (media_type == NULL) {
+		return NULL;
+	} else if (g_str_has_prefix (media_type, "audio/x-raw-") ||
+	    g_str_has_prefix (media_type, "video/x-raw-")) {
+		/* ignore raw types */
+		return NULL;
+	} else if (g_str_equal (media_type, "audio/mpeg")) {
+		/* need to distinguish between mpeg 1 layer 3 and
+		 * mpeg 2 or 4 here.
+		 */
+		int mpegversion = 0;
+		gst_structure_get_int (s, "mpegversion", &mpegversion);
+		switch (mpegversion) {
+		case 2:
+		case 4:
+			return g_strdup ("audio/x-aac");		/* hmm. */
+
+		case 1:
+		default:
+			return g_strdup ("audio/mpeg");
+		}
+	} else {
+		/* everything else is fine as-is */
+		return g_strdup (media_type);
+	}
+}
+
+GstCaps *
+rb_gst_media_type_to_caps (const char *media_type)
+{
+	/* special cases: */
+	if (strcmp (media_type, "audio/mpeg") == 0) {
+		return gst_caps_from_string ("audio/mpeg, mpegversion=(int)1");
+	} else if (strcmp (media_type, "audio/x-aac") == 0) {
+		return gst_caps_from_string ("audio/mpeg, mpegversion=(int){ 2, 4 }");
+	} else {
+		/* otherwise, the media type is enough */
+		return gst_caps_from_string (media_type);
+	}
+}
+
+const char *
+rb_gst_media_type_to_extension (const char *media_type)
+{
+	if (media_type == NULL) {
+		return NULL;
+	} else if (!strcmp (media_type, "audio/mpeg")) {
+		return "mp3";
+	} else if (!strcmp (media_type, "audio/x-vorbis") || !strcmp (media_type, "application/ogg")) {
+		return "ogg";
+	} else if (!strcmp (media_type, "audio/x-flac") || !strcmp (media_type, "audio/flac")) {
+		return "flac";
+	} else if (!strcmp (media_type, "audio/x-aac") || !strcmp (media_type, "audio/aac") || !strcmp (media_type, "audio/x-alac")) {
+		return "m4a";
+	} else if (!strcmp (media_type, "audio/x-wavpack")) {
+		return "wv";
+	} else {
+		return NULL;
+	}
+}
+
+const char *
+rb_gst_mime_type_to_media_type (const char *mime_type)
+{
+	if (!strcmp (mime_type, "application/x-id3") || !strcmp (mime_type, "audio/mpeg")) {
+		return "audio/mpeg";
+	} else if (!strcmp (mime_type, "application/ogg") || !strcmp (mime_type, "audio/x-vorbis")) {
+		return "audio/x-vorbis";
+	} else if (!strcmp (mime_type, "audio/flac")) {
+		return "audio/x-flac";
+	} else if (!strcmp (mime_type, "audio/aac") || !strcmp (mime_type, "audio/mp4") || !strcmp (mime_type, "audio/m4a")) {
+		return "audio/x-aac";
+	}
+	return mime_type;
+}
+
+const char *
+rb_gst_media_type_to_mime_type (const char *media_type)
+{
+	if (!strcmp (media_type, "audio/x-vorbis")) {
+		return "application/ogg";
+	} else if (!strcmp (media_type, "audio/x-flac")) {
+		return "audio/flac";
+	} else if (!strcmp (media_type, "audio/x-aac")) {
+		return "audio/mp4";	/* probably */
+	} else {
+		return media_type;
+	}
+}
+
+gboolean
+rb_gst_media_type_matches_profile (GstEncodingProfile *profile, const char *media_type)
+{
+	const GstCaps *pcaps;
+	const GList *cl;
+	GstCaps *caps;
+	gboolean matches = FALSE;
+
+	caps = rb_gst_media_type_to_caps (media_type);
+	if (caps == NULL) {
+		return FALSE;
+	}
+
+	pcaps = gst_encoding_profile_get_format (profile);
+	if (gst_caps_can_intersect (caps, pcaps)) {
+		matches = TRUE;
+	}
+
+	if (matches == FALSE && GST_IS_ENCODING_CONTAINER_PROFILE (profile)) {
+		for (cl = gst_encoding_container_profile_get_profiles (GST_ENCODING_CONTAINER_PROFILE (profile)); cl != NULL; cl = cl->next) {
+			GstEncodingProfile *cp = cl->data;
+			pcaps = gst_encoding_profile_get_format (cp);
+			if (gst_caps_can_intersect (caps, pcaps)) {
+				matches = TRUE;
+				break;
+			}
+		}
+	}
+	return matches;
+}
+
+char *
+rb_gst_encoding_profile_get_media_type (GstEncodingProfile *profile)
+{
+	if (GST_IS_ENCODING_CONTAINER_PROFILE (profile)) {
+		const GList *cl = gst_encoding_container_profile_get_profiles (GST_ENCODING_CONTAINER_PROFILE (profile));
+		for (; cl != NULL; cl = cl->next) {
+			GstEncodingProfile *p = cl->data;
+			if (GST_IS_ENCODING_AUDIO_PROFILE (p)) {
+				return rb_gst_caps_to_media_type (gst_encoding_profile_get_format (p));
+			}
+
+		}
+
+		/* now what? */
+		return NULL;
+	} else {
+		return rb_gst_caps_to_media_type (gst_encoding_profile_get_format (profile));
+	}
+}
+
+GstEncodingTarget *
+rb_gst_get_default_encoding_target ()
+{
+	if (default_target == NULL) {
+		char *target_file;
+		GError *error = NULL;
+
+		if (g_file_test (SOURCE_ENCODING_TARGET_FILE,
+			         G_FILE_TEST_EXISTS) != FALSE) {
+			target_file = SOURCE_ENCODING_TARGET_FILE;
+		} else {
+			target_file = INSTALLED_ENCODING_TARGET_FILE;
+		}
+
+		default_target = gst_encoding_target_load_from_file (target_file, &error);
+		if (default_target == NULL) {
+			g_warning ("Unable to load encoding profiles from %s: %s", target_file, error ? error->message : "no error");
+			g_clear_error (&error);
+			return NULL;
+		}
+	}
+
+	return default_target;
+}
+
+GstEncodingProfile *
+rb_gst_get_encoding_profile (const char *media_type)
+{
+	const GList *l;
+	GstEncodingTarget *target;
+	target = rb_gst_get_default_encoding_target ();
+
+	for (l = gst_encoding_target_get_profiles (target); l != NULL; l = l->next) {
+		GstEncodingProfile *profile = l->data;
+		if (rb_gst_media_type_matches_profile (profile, media_type)) {
+			gst_encoding_profile_ref (profile);
+			return profile;
+		}
+	}
+
+	return NULL;
+}
+
+gboolean
+rb_gst_media_type_is_lossless (const char *media_type)
+{
+	int i;
+	const char *lossless_types[] = {
+		"audio/x-flac",
+		"audio/x-alac",
+		"audio/x-shorten",
+		"audio/x-wavpack"	/* not completely sure */
+	};
+
+	for (i = 0; i < G_N_ELEMENTS (lossless_types); i++) {
+		if (strcmp (media_type, lossless_types[i]) == 0) {
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+gboolean
+rb_gst_check_missing_plugins (GstEncodingProfile *profile,
+			      char ***details,
+			      char ***descriptions)
+{
+	GstElement *encodebin;
+	GstBus *bus;
+	GstPad *pad;
+	gboolean ret;
+
+	ret = FALSE;
+
+	encodebin = gst_element_factory_make ("encodebin", NULL);
+	if (encodebin == NULL) {
+		g_warning ("Unable to create encodebin");
+		return TRUE;
+	}
+
+	bus = gst_bus_new ();
+	gst_element_set_bus (encodebin, bus);
+	gst_bus_set_flushing (bus, FALSE);		/* necessary? */
+
+	g_object_set (encodebin, "profile", profile, NULL);
+	pad = gst_element_get_static_pad (encodebin, "audio_0");
+	if (pad == NULL) {
+		GstMessage *message;
+		GList *messages = NULL;
+		GList *m;
+		int i;
+
+		message = gst_bus_pop (bus);
+		while (message != NULL) {
+			if (gst_is_missing_plugin_message (message)) {
+				messages = g_list_append (messages, message);
+			} else {
+				gst_message_unref (message);
+			}
+			message = gst_bus_pop (bus);
+		}
+
+		if (messages != NULL) {
+			if (details != NULL) {
+				*details = g_new0(char *, g_list_length (messages)+1);
+			}
+			if (descriptions != NULL) {
+				*descriptions = g_new0(char *, g_list_length (messages)+1);
+			}
+			i = 0;
+			for (m = messages; m != NULL; m = m->next) {
+				char *str;
+				if (details != NULL) {
+					str = gst_missing_plugin_message_get_installer_detail (m->data);
+					(*details)[i] = str;
+				}
+				if (descriptions != NULL) {
+					str = gst_missing_plugin_message_get_description (m->data);
+					(*descriptions)[i] = str;
+				}
+				i++;
+			}
+
+			ret = TRUE;
+			g_list_foreach (messages, (GFunc)gst_message_unref, NULL);
+			g_list_free (messages);
+		}
+
+	} else {
+		gst_element_release_request_pad (encodebin, pad);
+		gst_object_unref (pad);
+	}
+
+	gst_object_unref (encodebin);
+	gst_object_unref (bus);
+	return ret;
+}
diff --git a/libjuicer/rb-gst-media-types.h b/libjuicer/rb-gst-media-types.h
new file mode 100644
index 0000000..9211361
--- /dev/null
+++ b/libjuicer/rb-gst-media-types.h
@@ -0,0 +1,76 @@
+/*
+ *  Copyright (C) 2010  Jonathan Matthew <jonathan@d14n.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  The Rhythmbox authors hereby grant permission for non-GPL compatible
+ *  GStreamer plugins to be used and distributed together with GStreamer
+ *  and Rhythmbox. This permission is above and beyond the permissions granted
+ *  by the GPL license by which Rhythmbox is covered. If you modify this code
+ *  you may extend this exception to your version of the code, but you are not
+ *  obligated to do so. If you do not wish to do so, delete this exception
+ *  statement from your version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA.
+ *
+ */
+
+#ifndef __RB_GST_MEDIA_TYPES_H
+#define __RB_GST_MEDIA_TYPES_H
+
+#include <gst/gst.h>
+#include <gst/pbutils/encoding-target.h>
+#include <gst/pbutils/encoding-profile.h>
+
+G_BEGIN_DECLS
+
+/* some common media types */
+#define RB_GST_MEDIA_TYPE_MP3		"audio/mpeg"
+#define RB_GST_MEDIA_TYPE_OGG_VORBIS 	"audio/x-vorbis"
+#define RB_GST_MEDIA_TYPE_FLAC 		"audio/x-flac"
+#define RB_GST_MEDIA_TYPE_AAC 		"audio/x-aac"
+
+/* media type categories */
+typedef enum {
+	MEDIA_TYPE_NONE = 0,
+	MEDIA_TYPE_CONTAINER,
+	MEDIA_TYPE_AUDIO,
+	MEDIA_TYPE_VIDEO,
+	MEDIA_TYPE_OTHER
+} RBGstMediaType;
+
+char *		rb_gst_caps_to_media_type (const GstCaps *caps);
+GstCaps *	rb_gst_media_type_to_caps (const char *media_type);
+
+const char *	rb_gst_media_type_to_extension (const char *media_type);
+
+const char *	rb_gst_mime_type_to_media_type (const char *mime_type);
+
+const char *	rb_gst_media_type_to_mime_type (const char *media_type);
+
+GstEncodingTarget *rb_gst_get_default_encoding_target (void);
+
+GstEncodingProfile *rb_gst_get_encoding_profile (const char *media_type);
+
+gboolean	rb_gst_media_type_matches_profile (GstEncodingProfile *profile, const char *media_type);
+
+char *		rb_gst_encoding_profile_get_media_type (GstEncodingProfile *profile);
+
+gboolean	rb_gst_media_type_is_lossless (const char *media_type);
+gboolean	rb_gst_check_missing_plugins (GstEncodingProfile *profile,
+					      char ***details,
+					      char ***descriptions);
+
+G_END_DECLS
+
+#endif /* __RB_GST_MEDIA_TYPES_H */
diff --git a/libjuicer/sj-extractor.c b/libjuicer/sj-extractor.c
index 52f80d2..10523d4 100644
--- a/libjuicer/sj-extractor.c
+++ b/libjuicer/sj-extractor.c
@@ -30,7 +30,6 @@
 #include <glib-object.h>
 #include <gst/gst.h>
 #include <gst/tag/tag.h>
-#include <libgnome-media-profiles/gnome-media-profiles.h>
 #include "sj-extractor.h"
 #include "sj-structures.h"
 #include "sj-error.h"
@@ -56,18 +55,18 @@ enum {
 static guint signals[LAST_SIGNAL] = { 0 };
 
 /* Default profile name */
-#define DEFAULT_AUDIO_PROFILE_NAME "cdlossy"
+#define DEFAULT_MEDIA_TYPE "audio/x-vorbis"
 
 /* Element names */
 #define FILE_SINK "giosink"
 
 struct SjExtractorPrivate {
   /** The current audio profile */
-  GMAudioProfile *profile;
+  GstEncodingProfile *profile;
   /** If the pipeline needs to be re-created */
   gboolean rebuild_pipeline;
   /* The gstreamer pipeline elements */
-  GstElement *pipeline, *cdsrc, *queue, *thread, *encoder, *filesink;
+  GstElement *pipeline, *cdsrc, *encodebin, *filesink;
   GstFormat track_format;
   char *device_path;
   int paranoia_mode;
@@ -89,12 +88,14 @@ static void
 sj_extractor_set_property (GObject *object, guint property_id,
                                        const GValue *value, GParamSpec *pspec)
 {
+  GstEncodingProfile *profile;
   SjExtractorPrivate *priv = SJ_EXTRACTOR (object)->priv;
   switch (property_id) {
   case PROP_PROFILE:
     if (priv->profile)
-      g_object_unref (priv->profile);
-    priv->profile = GM_AUDIO_PROFILE (g_value_dup_object (value));
+      gst_encoding_profile_unref (priv->profile);
+    profile = GST_ENCODING_PROFILE (g_value_get_pointer (value));
+    priv->profile = GST_ENCODING_PROFILE(gst_encoding_profile_ref (profile));
     priv->rebuild_pipeline = TRUE;
     g_object_notify (object, "profile");
     break;
@@ -126,7 +127,7 @@ sj_extractor_get_property (GObject *object, guint property_id,
   SjExtractorPrivate *priv = SJ_EXTRACTOR (object)->priv;
   switch (property_id) {
   case PROP_PROFILE:
-    g_value_set_object (value, priv->profile);
+    g_value_set_pointer (value, gst_encoding_profile_ref (priv->profile));
     break;
   case PROP_DEVICE:
     g_value_set_string (value, priv->device_path);
@@ -142,7 +143,7 @@ sj_extractor_dispose (GObject *object)
   SjExtractorPrivate *priv = SJ_EXTRACTOR (object)->priv;
 
   if (priv->profile) {
-    g_object_unref (priv->profile);
+    gst_encoding_profile_unref (priv->profile);
     priv->profile = NULL;
   }
 
@@ -188,11 +189,10 @@ sj_extractor_class_init (SjExtractorClass *klass)
   /* Properties */
   /* TODO: make these constructors */
   g_object_class_install_property (object_class, PROP_PROFILE,
-                                   g_param_spec_object ("profile",
-                                                        _("Audio Profile"),
-                                                        _("The GNOME Audio Profile used for encoding audio"),
-                                                        GM_AUDIO_TYPE_PROFILE,
-                                                        G_PARAM_READWRITE));
+                                   g_param_spec_pointer ("profile",
+                                                         _("Audio Profile"),
+                                                         _("The GStreamer Encoding Profile used for encoding audio"),
+                                                         G_PARAM_READWRITE));
 
   g_object_class_install_property (object_class, PROP_PARANOIA,
                                    g_param_spec_int ("paranoia",
@@ -239,8 +239,7 @@ static void
 sj_extractor_init (SjExtractor *extractor)
 {
   extractor->priv = EXTRACTOR_PRIVATE (extractor);
-  extractor->priv->profile =
-    g_object_ref (gm_audio_profile_lookup (DEFAULT_AUDIO_PROFILE_NAME));
+  extractor->priv->profile = rb_gst_get_encoding_profile (DEFAULT_MEDIA_TYPE);
   extractor->priv->rebuild_pipeline = TRUE;
   extractor->priv->paranoia_mode = 8; /* TODO: replace with construct params */
 }
@@ -272,18 +271,20 @@ static GstElement*
 build_encoder (SjExtractor *extractor)
 {
   SjExtractorPrivate *priv;
-  GstElement *element = NULL;
-  char *pipeline;
+  GstElement *encodebin;
 
   g_return_val_if_fail (SJ_IS_EXTRACTOR (extractor), NULL);
   priv = (SjExtractorPrivate*)extractor->priv;
   g_return_val_if_fail (priv->profile != NULL, NULL);
- 
-  pipeline = g_strdup_printf ("audioresample ! audioconvert ! %s",
-                              gm_audio_profile_get_pipeline (priv->profile));
-  element = gst_parse_bin_from_description (pipeline, TRUE, NULL); /* TODO: return error */
-  g_free(pipeline);
-  return element;
+
+  encodebin = gst_element_factory_make ("encodebin", NULL);
+  if (encodebin == NULL)
+    return NULL;
+  g_object_set (encodebin, "profile", priv->profile, NULL);
+  /* Nice big buffers... */
+  g_object_set (encodebin, "queue-time-max", 120 * GST_SECOND, NULL);
+
+  return encodebin;
 }
 
 static void
@@ -357,16 +358,13 @@ build_pipeline (SjExtractor *extractor)
   priv->track_format = gst_format_get_by_nick ("track");
   g_assert (priv->track_format != 0);
 
-  priv->queue = gst_element_factory_make ("queue", "queue");
-  /* Nice big buffers... */
-  g_object_set (priv->queue, "max-size-time", 120 * GST_SECOND, NULL);
-  
   /* Encode */
-  priv->encoder = build_encoder (extractor);
-  if (priv->encoder == NULL) {
+  priv->encodebin = build_encoder (extractor);
+  if (priv->encodebin == NULL) {
     g_set_error (&priv->construct_error,
                  SJ_ERROR, SJ_ERROR_INTERNAL_ERROR,
-                 _("Could not create GStreamer encoders for %s"), gm_audio_profile_get_name (priv->profile));
+                 _("Could not create GStreamer encoders for %s"),
+                 gst_encoding_profile_get_name (priv->profile));
     return;
   }
   /* Connect to the eos so we know when its finished */
@@ -385,10 +383,10 @@ build_pipeline (SjExtractor *extractor)
 #endif
 
   /* Add the elements to the pipeline */
-  gst_bin_add_many (GST_BIN (priv->pipeline), priv->cdsrc, priv->queue, priv->encoder, priv->filesink, NULL);
+  gst_bin_add_many (GST_BIN (priv->pipeline), priv->cdsrc, priv->encodebin, priv->filesink, NULL);
 
   /* Link it all together */
-  if (!gst_element_link_many (priv->cdsrc, priv->queue, priv->encoder, priv->filesink, NULL)) {
+  if (!gst_element_link_many (priv->cdsrc, priv->encodebin, priv->filesink, NULL)) {
     g_set_error (&priv->construct_error,
                  SJ_ERROR, SJ_ERROR_INTERNAL_ERROR,
                  _("Could not link pipeline"));
@@ -669,30 +667,8 @@ sj_extractor_supports_encoding (GError **error)
 }
 
 gboolean
-sj_extractor_supports_profile (GMAudioProfile *profile)
+sj_extractor_supports_profile (GstEncodingProfile *profile)
 {
   /* TODO: take a GError to return a message if the profile isn't supported */
-  GstElement *element;
-  GError *error = NULL;
-  char *pipeline;
-
-  pipeline = g_strdup_printf ("fakesrc ! %s", gm_audio_profile_get_pipeline (profile));
-  element = gst_parse_launch (pipeline, &error);
-  g_free(pipeline);
-
-  /* It is possible for both element and error to be non NULL, so check both */
-  if (element) {
-    gst_object_unref (GST_OBJECT (element));
-    if (error) {
-      g_warning ("Profile warning: %s", error->message);
-      g_error_free (error);
-    }
-    return TRUE;
-  } else {
-    if (error) {
-      g_warning ("Profile error: %s", error->message);
-      g_error_free (error);
-    }
-    return FALSE;
-  }
+  return !rb_gst_check_missing_plugins(profile, NULL, NULL);
 }
diff --git a/libjuicer/sj-extractor.h b/libjuicer/sj-extractor.h
index bbe23fc..7e71803 100644
--- a/libjuicer/sj-extractor.h
+++ b/libjuicer/sj-extractor.h
@@ -26,7 +26,7 @@
 #include <glib.h>
 #include <glib-object.h>
 #include <gio/gio.h>
-#include <libgnome-media-profiles/audio-profile.h>
+#include "rb-gst-media-types.h"
 #include "sj-structures.h"
 
 G_BEGIN_DECLS
@@ -71,7 +71,7 @@ void sj_extractor_extract_track (SjExtractor *extractor, const TrackDetails *tra
 
 void sj_extractor_cancel_extract (SjExtractor *extractor);
 
-gboolean sj_extractor_supports_profile (GMAudioProfile *profile);
+gboolean sj_extractor_supports_profile (GstEncodingProfile *profile);
 
 gboolean sj_extractor_supports_encoding (GError **error);
 
diff --git a/libjuicer/sj-metadata-musicbrainz3.c b/libjuicer/sj-metadata-musicbrainz3.c
index ee96946..3bcb3cf 100644
--- a/libjuicer/sj-metadata-musicbrainz3.c
+++ b/libjuicer/sj-metadata-musicbrainz3.c
@@ -25,9 +25,9 @@
 
 #include <string.h>
 #include <stdlib.h>
+#include <gio/gio.h>
 #include <glib.h>
 #include <glib-object.h>
-#include <gconf/gconf-client.h>
 #include <musicbrainz3/mb_c.h>
 
 #include "sj-metadata-musicbrainz3.h"
@@ -64,13 +64,15 @@
 }
 #endif /* HAVE_MB_EXTRACT_UUID */
 
-#define GCONF_MUSICBRAINZ_SERVER "/apps/sound-juicer/musicbrainz_server"
-#define GCONF_PROXY_USE_PROXY "/system/http_proxy/use_http_proxy"
-#define GCONF_PROXY_HOST "/system/http_proxy/host"
-#define GCONF_PROXY_PORT "/system/http_proxy/port"
-#define GCONF_PROXY_USE_AUTHENTICATION "/system/http_proxy/use_authentication"
-#define GCONF_PROXY_USERNAME "/system/http_proxy/authentication_user"
-#define GCONF_PROXY_PASSWORD "/system/http_proxy/authentication_password"
+#if 0
+#define SJ_SETTINGS_MUSICBRAINZ_SERVER "/apps/sound-juicer/musicbrainz_server"
+#endif
+#define SJ_SETTINGS_PROXY_USE_PROXY "enabled"
+#define SJ_SETTINGS_PROXY_HOST "host"
+#define SJ_SETTINGS_PROXY_PORT "port"
+#define SJ_SETTINGS_PROXY_USE_AUTHENTICATION "use-authentication"
+#define SJ_SETTINGS_PROXY_USERNAME "authentication-user"
+#define SJ_SETTINGS_PROXY_PASSWORD "authentication-password"
 
 typedef struct {
   MbWebService mb;
@@ -317,8 +319,7 @@ metadata_interface_init (gpointer g_iface, gpointer iface_data)
 static void
 sj_metadata_musicbrainz3_init (SjMetadataMusicbrainz3 *self)
 {
-  GConfClient *gconf_client;
-  gchar *server_name;
+  GSettings *settings;
 
   SjMetadataMusicbrainz3Private *priv;
 
@@ -326,42 +327,46 @@ sj_metadata_musicbrainz3_init (SjMetadataMusicbrainz3 *self)
 
   priv->mb = mb_webservice_new ();
 
-  gconf_client = gconf_client_get_default ();
+  settings = g_settings_new ("org.gnome.system.proxy.http");
+
+#if 0
+  gchar *server_name;
 
-  server_name = gconf_client_get_string (gconf_client, GCONF_MUSICBRAINZ_SERVER, NULL);
+  server_name = g_settings_get_string (settings, SJ_SETTINGS_MUSICBRAINZ_SERVER);
 
   if (server_name && strcmp (server_name, "") != 0) {
     mb_webservice_set_host (priv->mb, server_name);
   }
 
   g_free (server_name);
+#endif
 
   /* Set the HTTP proxy */
-  if (gconf_client_get_bool (gconf_client, GCONF_PROXY_USE_PROXY, NULL)) {
+  if (g_settings_get_boolean (settings, SJ_SETTINGS_PROXY_USE_PROXY)) {
     char *proxy_host;
     int port;
 
-    proxy_host = gconf_client_get_string (gconf_client, GCONF_PROXY_HOST, NULL);
+    proxy_host = g_settings_get_string (settings, SJ_SETTINGS_PROXY_HOST);
     mb_webservice_set_proxy_host (priv->mb, proxy_host);
     g_free (proxy_host);
 
-    port = gconf_client_get_int (gconf_client, GCONF_PROXY_PORT, NULL);
+    port = g_settings_get_int (settings, SJ_SETTINGS_PROXY_PORT);
     mb_webservice_set_proxy_port (priv->mb, port);
 
-    if (gconf_client_get_bool (gconf_client, GCONF_PROXY_USE_AUTHENTICATION, NULL)) {
+    if (g_settings_get_boolean (settings, SJ_SETTINGS_PROXY_USE_AUTHENTICATION)) {
       char *username, *password;
 
-      username = gconf_client_get_string (gconf_client, GCONF_PROXY_USERNAME, NULL);
+      username = g_settings_get_string (settings, SJ_SETTINGS_PROXY_USERNAME);
       mb_webservice_set_proxy_username (priv->mb, username);
       g_free (username);
 
-      password = gconf_client_get_string (gconf_client, GCONF_PROXY_PASSWORD, NULL);
+      password = g_settings_get_string (settings, SJ_SETTINGS_PROXY_PASSWORD);
       mb_webservice_set_proxy_password (priv->mb, password);
       g_free (password);
     }
   }
 
-  g_object_unref (gconf_client);
+  g_object_unref (settings);
 }
 
 static void
diff --git a/po/POTFILES.in b/po/POTFILES.in
index 7b38ab5..8a073dd 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -3,7 +3,6 @@
 [encoding: UTF-8]
 data/sound-juicer.desktop.in.in
 [type: gettext/glade]data/sound-juicer.ui
-data/sound-juicer.schemas.in
 libjuicer/sj-error.c
 libjuicer/sj-extractor.c
 libjuicer/sj-metadata.c
@@ -13,7 +12,6 @@ libjuicer/sj-metadata-musicbrainz3.c
 libjuicer/sj-structures.c
 libjuicer/sj-util.c
 src/egg-play-preview.c
-src/gconf-bridge.c
 src/sj-about.c
 src/sj-extracting.c
 src/sj-genres.c
diff --git a/sound-juicer.spec.in b/sound-juicer.spec.in
index 4c3e4ff..d2f7420 100644
--- a/sound-juicer.spec.in
+++ b/sound-juicer.spec.in
@@ -10,13 +10,11 @@ Requires:	libmusicbrainz >= 2.0.1
 Requires:	libgnomeui >= 2.0.0
 Requires:	glib2 >= 2.0.0
 Requires:	gstreamer >= 0.8.0
-Requires:	GConf2 >= 2.0.0
 Requires:	gstreamer-plugins-base >= 0.7.2
 BuildRequires:	libmusicbrainz-devel >= 2.0.1
 BuildRequires:	libgnomeui-devel >= 2.0.0
 BuildRequires:	glib2-devel >= 2.0.0
 BuildRequires:	gstreamer-devel >= 0.8.0
-BuildRequires:	GConf2-devel >= 2.0.0
 BuildRequires:  scrollkeeper >= @SCROLLKEEPER_BUILD_REQUIRED@
 
 %description
@@ -31,9 +29,7 @@ GStreamer-based CD ripping tool. Saves audio CDs to Ogg Vorbis or FLAC.
 
 make
 
-export GCONF_DISABLE_MAKEFILE_SCHEMA_INSTALL=1;
 %makeinstall
-unset GCONF_DISABLE_MAKEFILE_SCHEMA_INSTALL
 
 # Clean out bad files
 rm -rf $RPM_BUILD_ROOT%{_localstatedir}/scrollkeeper
@@ -45,19 +41,10 @@ rm -rf $RPM_BUILD_ROOT/usr/share/icons/hicolor/icon-theme.cache
 %clean
 [ -n "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf $RPM_BUILD_ROOT
 
-%preun
-export GCONF_CONFIG_SOURCE=`gconftool-2 --get-default-source` 
-gconftool-2 --makefile-uninstall-rule %{_sysconfdir}/gconf/schemas/sound-juicer.schemas > /dev/null
-
-%post
-export GCONF_CONFIG_SOURCE=`gconftool-2 --get-default-source` 
-gconftool-2 --makefile-install-rule %{_sysconfdir}/gconf/schemas/sound-juicer.schemas > /dev/null
-
 %files -f sound-juicer.lang
 %defattr(-, root, root)
 %doc AUTHORS COPYING ChangeLog INSTALL README NEWS
 %{_bindir}/sound-juicer
-%{_sysconfdir}/gconf/schemas/sound-juicer.schemas
 %{_datadir}/sound-juicer
 %{_datadir}/applications/sound-juicer.desktop
 %{_datadir}/icons/hicolor/16x16
diff --git a/src/Makefile.am b/src/Makefile.am
index 716ac6c..cd719f4 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -16,8 +16,6 @@ sound_juicer_SOURCES = \
 	sj-inhibit.c \
 	sj-genres.h \
 	sj-genres.c \
-	gconf-bridge.h \
-	gconf-bridge.c \
 	egg-play-preview.c \
 	egg-play-preview.h \
 	$(BACON_FILES)
@@ -36,15 +34,6 @@ sound_juicer_CPPFLAGS = \
 
 sound_juicer_CFLAGS = \
 	$(GSTREAMER_CFLAGS) \
-	$(MEDIA_PROFILES_CFLAGS) \
-	$(BURN_CFLAGS) \
-	$(UI_CFLAGS) \
-	$(WARN_CFLAGS) \
-	$(AM_CFLAGS)
-
-sound_juicer_CFLAGS = \
-	$(GSTREAMER_CFLAGS) \
-	$(MEDIA_PROFILES_CFLAGS) \
 	$(BURN_CFLAGS) \
 	$(UI_CFLAGS) \
 	$(WARN_CFLAGS) \
@@ -52,7 +41,6 @@ sound_juicer_CFLAGS = \
 
 sound_juicer_LDADD = \
 	$(top_builddir)/libjuicer/libjuicer.la \
-	$(MEDIA_PROFILES_LIBS) \
 	$(GSTREAMER_LIBS) \
 	$(BURN_LIBS) \
 	$(UI_LIBS)
diff --git a/src/egg-play-preview.c b/src/egg-play-preview.c
index 0d7e99f..b8fb50a 100644
--- a/src/egg-play-preview.c
+++ b/src/egg-play-preview.c
@@ -529,7 +529,7 @@ _setup_pipeline (EggPlayPreview *play_preview)
 	if (!priv->playbin)
 		return;
 
-	audiosink = gst_element_factory_make ("gconfaudiosink", "audiosink");
+	audiosink = gst_element_factory_make ("gsettingsaudiosink", "audiosink");
 	if (!audiosink) {
 		audiosink = gst_element_factory_make ("autoaudiosink", "audiosink");
 		if (!audiosink) {
diff --git a/src/gconf-bridge.c b/src/gconf-bridge.c
deleted file mode 100644
index 88fc67f..0000000
--- a/src/gconf-bridge.c
+++ /dev/null
@@ -1,1246 +0,0 @@
-/* 
- * (C) 2005 OpenedHand Ltd.
- *
- * Author: Jorn Baayen <jorn@openedhand.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include <config.h>
-
-#include <glib/gi18n-lib.h>
-#include <gtk/gtk.h>
-#include <string.h>
-
-#include "gconf-bridge.h"
-
-struct _GConfBridge {
-        GConfClient *client;
-        
-        GHashTable *bindings;
-};
-
-/* The data structures for the different kinds of bindings */
-typedef enum {
-        BINDING_PROP,
-        BINDING_WINDOW,
-        BINDING_LIST_STORE
-} BindingType;
-
-typedef struct {
-        BindingType type;
-        guint id;
-        
-        gboolean delayed_mode;
-
-        char *key;
-        guint val_notify_id;
-        GSList *val_changes; /* List of changes made to GConf value,
-                                that have not received change notification
-                                yet. */
-
-        GObject *object;
-        GParamSpec *prop;
-        gulong prop_notify_id;
-
-        guint sync_timeout_id; /* Used in delayed mode */
-} PropBinding;
-
-typedef struct {
-        BindingType type;
-        guint id;
-
-        gboolean bind_size;
-        gboolean bind_pos;
-
-        char *key_prefix;
-
-        GtkWindow *window;
-        gulong configure_event_id;
-        gulong unmap_id;
-        guint sync_timeout_id;
-} WindowBinding;
-
-typedef struct {
-        BindingType type;
-        guint id;
-
-        char *key;
-        guint val_notify_id;
-        GSList *val_changes; /* List of changes made to GConf value,
-                                that have not received change notification
-                                yet. */
-
-        GtkListStore *list_store;
-        guint row_inserted_id;
-        guint row_changed_id;
-        guint row_deleted_id;
-        guint rows_reordered_id;
-
-        guint sync_idle_id;
-} ListStoreBinding;
-
-/* Some trickery to be able to treat the data structures generically */
-typedef union {
-        BindingType      type;
-
-        PropBinding      prop_binding;
-        WindowBinding    window_binding;
-        ListStoreBinding list_store_binding;
-} Binding;
-
-/* Function prototypes */
-static void
-unbind (Binding *binding);
-
-#if !HAVE_DECL_GCONF_VALUE_COMPARE /* Not in headers in GConf < 2.13 */
-int gconf_value_compare (const GConfValue *value_a,
-                         const GConfValue *value_b);
-#endif
-
-static GConfBridge *bridge = NULL; /* Global GConfBridge object */
-
-/* Free up all resources allocated by the GConfBridge. Called on exit. */
-static void
-destroy_bridge (void)
-{
-        g_hash_table_destroy (bridge->bindings);
-        g_object_unref (bridge->client);
-
-        g_free (bridge);
-}
-
-/**
- * gconf_bridge_get
- *
- * Returns the #GConfBridge. This is a singleton object.
- *
- * Return value: The #GConfBridge.
- **/
-GConfBridge *
-gconf_bridge_get (void)
-{
-        if (bridge)
-                return bridge;
-
-        gconf_bridge_install_default_error_handler ();
-
-        bridge = g_new (GConfBridge, 1);
-
-        bridge->client = gconf_client_get_default ();
-        bridge->bindings = g_hash_table_new_full (NULL, NULL, NULL,
-                                                  (GDestroyNotify) unbind);
-
-        g_atexit (destroy_bridge);
-
-        return bridge;
-}
-
-/**
- * gconf_bridge_get_client
- * @bridge: A #GConfBridge
- *
- * Returns the #GConfClient used by @bridge. This is the same #GConfClient 
- * as returned by gconf_client_get_default().
- *
- * Return value: A #GConfClient.
- **/
-GConfClient *
-gconf_bridge_get_client (GConfBridge *bridge)
-{
-        g_return_val_if_fail (bridge != NULL, NULL);
-
-        return bridge->client;
-}
-
-/* Generate an ID for a new binding */
-static guint
-new_id (void)
-{
-        static guint id_counter = 0;
-
-        id_counter++;
-
-        return id_counter;
-}
-
-/*
- * Property bindings
- */
-
-/* Syncs a value from GConf to an object property */
-static void
-prop_binding_sync_pref_to_prop (PropBinding *binding,
-                                GConfValue  *pref_value)
-{
-        GValue src_value, value;
-        
-        /* Make sure we don't enter an infinite synchronizing loop */
-        g_signal_handler_block (binding->object, binding->prop_notify_id);
-
-        memset (&src_value, 0, sizeof (GValue));
-
-        /* First, convert GConfValue to GValue */
-        switch (pref_value->type) {
-        case GCONF_VALUE_STRING:
-                g_value_init (&src_value, G_TYPE_STRING);
-                g_value_set_string (&src_value,
-                                    gconf_value_get_string (pref_value));
-                break;
-        case GCONF_VALUE_INT:
-                g_value_init (&src_value, G_TYPE_INT);
-                g_value_set_int (&src_value,
-                                 gconf_value_get_int (pref_value));
-                break;
-        case GCONF_VALUE_BOOL:
-                g_value_init (&src_value, G_TYPE_BOOLEAN);
-                g_value_set_boolean (&src_value,
-                                     gconf_value_get_bool (pref_value));
-                break;
-        case GCONF_VALUE_FLOAT:
-                g_value_init (&src_value, G_TYPE_FLOAT);
-                g_value_set_float (&src_value,
-                                   gconf_value_get_float (pref_value));
-                break;
-        default:
-                g_warning ("prop_binding_sync_pref_to_prop: Unhandled value "
-                           "type '%d'.\n", pref_value->type);
-
-                return;
-        }
-
-        /* Then convert to the type expected by the object, if necessary */
-        memset (&value, 0, sizeof (GValue));
-        g_value_init (&value,
-                      G_PARAM_SPEC_VALUE_TYPE (binding->prop));
-
-        if (src_value.g_type != value.g_type) {
-                if (!g_value_transform (&src_value, &value)) {
-                        g_warning ("prop_binding_sync_pref_to_prop: Failed to "
-                                   "transform a \"%s\" to a \"%s\".",
-                                   g_type_name (src_value.g_type),
-                                   g_type_name (value.g_type));
-                        
-                        goto done;
-                }
-
-                g_object_set_property (binding->object,
-                                       binding->prop->name, &value);
-        } else {
-                g_object_set_property (binding->object,
-                                       binding->prop->name, &src_value);
-        }
-        
-done:
-        g_value_unset (&src_value);
-        g_value_unset (&value);
-
-        g_signal_handler_unblock (binding->object, binding->prop_notify_id);
-}
-
-/* Syncs an object property to GConf */
-static void
-prop_binding_sync_prop_to_pref (PropBinding *binding)
-{
-        GValue value;
-        GConfValue *gconf_value;
-
-        memset (&value, 0, sizeof (GValue));
-
-        g_value_init (&value,
-                      G_PARAM_SPEC_VALUE_TYPE (binding->prop));
-        g_object_get_property (binding->object,
-                               binding->prop->name,
-                               &value);
-
-        switch (value.g_type) {
-        case G_TYPE_STRING:
-                gconf_value = gconf_value_new (GCONF_VALUE_STRING);
-                gconf_value_set_string (gconf_value,
-                                        g_value_get_string (&value));
-                break;
-        case G_TYPE_INT:
-                gconf_value = gconf_value_new (GCONF_VALUE_INT);
-                gconf_value_set_int (gconf_value,
-                                     g_value_get_int (&value));
-                break;
-        case G_TYPE_UINT:
-                gconf_value = gconf_value_new (GCONF_VALUE_INT);
-                gconf_value_set_int (gconf_value,
-                                     g_value_get_uint (&value));
-                break;
-        case G_TYPE_LONG:
-                gconf_value = gconf_value_new (GCONF_VALUE_INT);
-                gconf_value_set_int (gconf_value,
-                                     g_value_get_long (&value));
-                break;
-        case G_TYPE_ULONG:
-                gconf_value = gconf_value_new (GCONF_VALUE_INT);
-                gconf_value_set_int (gconf_value,
-                                     g_value_get_ulong (&value));
-                break;
-        case G_TYPE_INT64:
-                gconf_value = gconf_value_new (GCONF_VALUE_INT);
-                gconf_value_set_int (gconf_value,
-                                     g_value_get_int64 (&value));
-                break;
-        case G_TYPE_UINT64:
-                gconf_value = gconf_value_new (GCONF_VALUE_INT);
-                gconf_value_set_int (gconf_value,
-                                     g_value_get_uint64 (&value));
-                break;
-        case G_TYPE_CHAR:
-                gconf_value = gconf_value_new (GCONF_VALUE_INT);
-                gconf_value_set_int (gconf_value,
-                                     g_value_get_char (&value));
-                break;
-        case G_TYPE_UCHAR:
-                gconf_value = gconf_value_new (GCONF_VALUE_INT);
-                gconf_value_set_int (gconf_value,
-                                     g_value_get_uchar (&value));
-                break;
-        case G_TYPE_ENUM:
-                gconf_value = gconf_value_new (GCONF_VALUE_INT);
-                gconf_value_set_int (gconf_value,
-                                     g_value_get_enum (&value));
-                break;
-        case G_TYPE_BOOLEAN:
-                gconf_value = gconf_value_new (GCONF_VALUE_BOOL);
-                gconf_value_set_bool (gconf_value,
-                                      g_value_get_boolean (&value));
-                break;
-        case G_TYPE_DOUBLE:
-                gconf_value = gconf_value_new (GCONF_VALUE_FLOAT);
-#ifdef HAVE_CORBA_GCONF
-                /* FIXME we cast to a float explicitly as CORBA GConf
-                 * uses doubles in its API, but treats them as floats
-                 * when transporting them over CORBA. See #322837 */
-                gconf_value_set_float (gconf_value,
-                                       (float) g_value_get_double (&value));
-#else
-                gconf_value_set_float (gconf_value,
-                                       g_value_get_double (&value));
-#endif
-                break;
-        case G_TYPE_FLOAT:
-                gconf_value = gconf_value_new (GCONF_VALUE_FLOAT);
-                gconf_value_set_float (gconf_value,
-                                       g_value_get_float (&value));
-                break;
-        default:
-                if (g_type_is_a (value.g_type, G_TYPE_ENUM)) {
-                        gconf_value = gconf_value_new (GCONF_VALUE_INT);
-                        gconf_value_set_int (gconf_value,
-                                             g_value_get_enum (&value));
-                } else {
-                        g_warning ("prop_binding_sync_prop_to_pref: "
-                                   "Unhandled value type '%s'.\n",
-                                   g_type_name (value.g_type));
-
-                        goto done;
-                }
-
-                break;
-        }
-
-        /* Set to GConf */
-        gconf_client_set (bridge->client, binding->key, gconf_value, NULL);
-
-        /* Store until change notification comes in, so that we are able
-         * to ignore it */
-        binding->val_changes = g_slist_append (binding->val_changes,
-                                               gconf_value);
-
-done:
-        g_value_unset (&value);
-}
-
-/* Called when a GConf value bound to an object property has changed */
-static void
-prop_binding_pref_changed (GConfClient *client,
-                           guint        cnxn_id,
-                           GConfEntry  *entry,
-                           gpointer     user_data)
-{
-        GConfValue *gconf_value;
-        PropBinding *binding;
-        GSList *l;
-
-        gconf_value = gconf_entry_get_value (entry);
-        if (!gconf_value)
-                return; /* NULL means that the value has been unset */
-
-        binding = (PropBinding *) user_data;
-
-        /* Check that this notification is not caused by sync_prop_to_pref() */
-        l = g_slist_find_custom (binding->val_changes,
-                                 gconf_value,
-                                 (GCompareFunc) gconf_value_compare);
-        if (l) {
-                gconf_value_free (l->data);
-
-                binding->val_changes = g_slist_delete_link
-                        (binding->val_changes, l);
-
-                return;
-        }
-
-        prop_binding_sync_pref_to_prop (binding, gconf_value);
-}
-
-/* Performs a scheduled prop-to-pref sync for a prop binding in 
- * delay mode */
-static gboolean
-prop_binding_perform_scheduled_sync (PropBinding *binding)
-{
-        prop_binding_sync_prop_to_pref (binding);
-
-        binding->sync_timeout_id = 0;
-
-        g_object_unref (binding->object);
-        
-        return FALSE;
-}
-
-#define PROP_BINDING_SYNC_DELAY 100 /* Delay for bindings with "delayed"
-                                       set to TRUE, in ms */
-
-/* Called when an object property has changed */
-static void
-prop_binding_prop_changed (GObject     *object,
-                           GParamSpec  *param_spec,
-                           PropBinding *binding)
-{
-        if (binding->delayed_mode) {
-                /* Just schedule a sync */
-                if (binding->sync_timeout_id == 0) {
-                        /* We keep a reference on the object as long as
-                         * we haven't synced yet to make sure we don't
-                         * lose any data */
-                        g_object_ref (binding->object);
-
-                        binding->sync_timeout_id =
-                                g_timeout_add
-                                        (PROP_BINDING_SYNC_DELAY,
-                                         (GSourceFunc)
-                                            prop_binding_perform_scheduled_sync,
-                                         binding);
-                }
-        } else {
-                /* Directly sync */
-                prop_binding_sync_prop_to_pref (binding);
-        }
-}
-
-/* Called when an object is destroyed */
-static void
-prop_binding_object_destroyed (gpointer user_data,
-                               GObject *where_the_object_was)
-{
-        PropBinding *binding;
-
-        binding = (PropBinding *) user_data;
-        binding->object = NULL; /* Don't do anything with the object
-                                   at unbind() */
-        
-        g_hash_table_remove (bridge->bindings,
-                             GUINT_TO_POINTER (binding->id));
-}
-
-/**
- * gconf_bridge_bind_property_full
- * @bridge: A #GConfBridge
- * @key: A GConf key to be bound
- * @object: A #GObject
- * @prop: The property of @object to be bound
- * @delayed_sync: TRUE if there should be a delay between property changes
- * and syncs to GConf. Set to TRUE when binding to a rapidly-changing
- * property, for example the "value" property on a #GtkAdjustment.
- *
- * Binds @key to @prop, causing them to have the same value at all times.
- *
- * The types of @key and @prop should be compatible. Floats and doubles, and
- * ints, uints, longs, unlongs, int64s, uint64s, chars, uchars and enums
- * can be matched up. Booleans and strings can only be matched to their
- * respective types.
- *
- * On calling this function the current value of @key will be set to @prop.
- *
- * Return value: The ID of the new binding.
- **/
-guint
-gconf_bridge_bind_property_full (GConfBridge *bridge,
-                                 const char  *key,
-                                 GObject     *object,
-                                 const char  *prop,
-                                 gboolean     delayed_sync)
-{
-        GParamSpec *pspec;
-        PropBinding *binding;
-        char *signal;
-        GConfValue *val;
-
-        g_return_val_if_fail (bridge != NULL, 0);
-        g_return_val_if_fail (key != NULL, 0);
-        g_return_val_if_fail (G_IS_OBJECT (object), 0);
-        g_return_val_if_fail (prop != NULL, 0);
-
-        /* First, try to fetch the propertys GParamSpec off the object */
-        pspec = g_object_class_find_property
-                                (G_OBJECT_GET_CLASS (object), prop);
-        if (G_UNLIKELY (pspec == NULL)) {
-                g_warning ("gconf_bridge_bind_property_full: A property \"%s\" "
-                           "was not found. Please make sure you are passing "
-                           "the right property name.", prop);
-
-                return 0;
-        }
-
-        /* GParamSpec found: All good, create new binding. */
-        binding = g_new (PropBinding, 1);
-
-        binding->type = BINDING_PROP;
-        binding->id = new_id ();
-        binding->delayed_mode = delayed_sync;
-        binding->val_changes = NULL;
-        binding->key = g_strdup (key);
-        binding->object = object;
-        binding->prop = pspec;
-        binding->sync_timeout_id = 0;
-        
-        /* Watch GConf key */
-        binding->val_notify_id =
-                gconf_client_notify_add (bridge->client, key,
-                                         prop_binding_pref_changed,
-                                         binding, NULL, NULL);
-
-        /* Connect to property change notifications */
-        signal = g_strconcat ("notify::", prop, NULL);
-        binding->prop_notify_id =
-                g_signal_connect (object, signal,
-                                  G_CALLBACK (prop_binding_prop_changed),
-                                  binding);
-        g_free (signal);
-
-        /* Sync object to value from GConf, if set */
-        val = gconf_client_get (bridge->client, key, NULL);
-        if (val) {
-                prop_binding_sync_pref_to_prop (binding, val);
-                gconf_value_free (val);
-        }
-
-        /* Handle case where watched object gets destroyed */
-        g_object_weak_ref (object,
-                           prop_binding_object_destroyed, binding);
-
-        /* Insert binding */
-        g_hash_table_insert (bridge->bindings,
-                             GUINT_TO_POINTER (binding->id), binding);
-
-        /* Done */
-        return binding->id;
-}
-
-/* Unbinds a property binding */
-static void
-prop_binding_unbind (PropBinding *binding)
-{
-        if (binding->delayed_mode && binding->sync_timeout_id > 0) {
-                /* Perform any scheduled syncs */
-                g_source_remove (binding->sync_timeout_id);
-                        
-                /* The object will still be around as we have
-                 * a reference */
-                prop_binding_perform_scheduled_sync (binding);
-        }
-
-        gconf_client_notify_remove (bridge->client,
-                                    binding->val_notify_id);
-        g_free (binding->key);
-
-        while (binding->val_changes) {
-                gconf_value_free (binding->val_changes->data);
-
-                binding->val_changes = g_slist_delete_link
-                        (binding->val_changes, binding->val_changes);
-        }
-
-        /* The object might have been destroyed .. */
-        if (binding->object) {
-                g_signal_handler_disconnect (binding->object,
-                                             binding->prop_notify_id);
-
-                g_object_weak_unref (binding->object,
-                                     prop_binding_object_destroyed, binding);
-        }
-}
-
-/*
- * Window bindings
- */
-
-/* Performs a scheduled dimensions-to-prefs sync for a window binding */
-static gboolean
-window_binding_perform_scheduled_sync (WindowBinding *binding)
-{
-        if (binding->bind_size) {
-                int width, height;
-                char *key;
-                GdkWindowState state;
-
-                state = gdk_window_get_state (gtk_widget_get_window (GTK_WIDGET (binding->window)));
-
-                if (state & GDK_WINDOW_STATE_MAXIMIZED) {
-                        key = g_strconcat (binding->key_prefix, "_maximized", NULL);
-                        gconf_client_set_bool (bridge->client, key, TRUE, NULL);
-                        g_free (key);
-                } else {
-                        gtk_window_get_size (binding->window, &width, &height);
-
-                        key = g_strconcat (binding->key_prefix, "_width", NULL);
-                        gconf_client_set_int (bridge->client, key, width, NULL);
-                        g_free (key);
-
-                        key = g_strconcat (binding->key_prefix, "_height", NULL);
-                        gconf_client_set_int (bridge->client, key, height, NULL);
-                        g_free (key);
-
-                        key = g_strconcat (binding->key_prefix, "_maximized", NULL);
-                        gconf_client_set_bool (bridge->client, key, FALSE, NULL);
-                        g_free (key);
-                }
-        }
-
-        if (binding->bind_pos) {
-                int x, y;
-                char *key;
-
-                gtk_window_get_position (binding->window, &x, &y);
-
-                key = g_strconcat (binding->key_prefix, "_x", NULL);
-                gconf_client_set_int (bridge->client, key, x, NULL);
-                g_free (key);
-
-                key = g_strconcat (binding->key_prefix, "_y", NULL);
-                gconf_client_set_int (bridge->client, key, y, NULL);
-                g_free (key);
-        }
-
-        binding->sync_timeout_id = 0;
-
-        return FALSE;
-}
-
-#define WINDOW_BINDING_SYNC_DELAY 1000 /* Delay before syncing new window
-                                          dimensions to GConf, in ms */
-
-/* Called when the window han been resized or moved */
-static gboolean
-window_binding_configure_event_cb (GtkWindow         *window,
-                                   GdkEventConfigure *event,
-                                   WindowBinding     *binding)
-{
-        /* Schedule a sync */
-        if (binding->sync_timeout_id == 0) {
-                binding->sync_timeout_id =
-                        g_timeout_add (WINDOW_BINDING_SYNC_DELAY,
-                                       (GSourceFunc)
-                                          window_binding_perform_scheduled_sync,
-                                       binding);
-        }
-
-        return FALSE;
-}
-
-/* Called when the window state is being changed */
-static gboolean
-window_binding_state_event_cb (GtkWindow           *window,
-                               GdkEventWindowState *event,
-                               WindowBinding       *binding)
-{
-        window_binding_perform_scheduled_sync (binding);
-
-        return FALSE;
-}
-
-/* Called when the window is being unmapped */
-static gboolean
-window_binding_unmap_cb (GtkWindow     *window,
-                         WindowBinding *binding)
-{
-        /* Force sync */
-        if (binding->sync_timeout_id > 0)
-                g_source_remove (binding->sync_timeout_id);
-
-        window_binding_perform_scheduled_sync (binding);
-
-        return FALSE;
-}
-
-/* Called when a window is destroyed */
-static void
-window_binding_window_destroyed (gpointer user_data,
-                                 GObject *where_the_object_was)
-{
-        WindowBinding *binding;
-
-        binding = (WindowBinding *) user_data;
-        binding->window = NULL; /* Don't do anything with the window
-                                   at unbind() */
-        
-        g_hash_table_remove (bridge->bindings,
-                             GUINT_TO_POINTER (binding->id));
-}
-
-/**
- * gconf_bridge_bind_window
- * @bridge: A #GConfBridge
- * @key_prefix: The prefix of the GConf keys
- * @window: A #GtkWindow
- * @bind_size: TRUE to bind the size of @window
- * @bind_pos: TRUE to bind the position of @window
- * 
- * On calling this function @window will be resized to the values
- * specified by "@key_prefix<!-- -->_width" and "@key_prefix<!-- -->_height"
- * and maximixed if "@key_prefix<!-- -->_maximized is TRUE if
- * @bind_size is TRUE, and moved to the values specified by
- * "@key_prefix<!-- -->_x" and "@key_prefix<!-- -->_y" if @bind_pos is TRUE.
- * The respective GConf values will be updated when the window is resized
- * and/or moved.
- *
- * Return value: The ID of the new binding.
- **/
-guint
-gconf_bridge_bind_window (GConfBridge *bridge,
-                          const char  *key_prefix,
-                          GtkWindow   *window,
-                          gboolean     bind_size,
-                          gboolean     bind_pos)
-{
-        WindowBinding *binding;
-
-        g_return_val_if_fail (bridge != NULL, 0);
-        g_return_val_if_fail (key_prefix != NULL, 0);
-        g_return_val_if_fail (GTK_IS_WINDOW (window), 0);
-
-        /* Create new binding. */
-        binding = g_new (WindowBinding, 1);
-
-        binding->type = BINDING_WINDOW;
-        binding->id = new_id ();
-        binding->bind_size = bind_size;
-        binding->bind_pos = bind_pos;
-        binding->key_prefix = g_strdup (key_prefix);
-        binding->window = window;
-        binding->sync_timeout_id = 0;
-
-        /* Set up GConf keys & sync window to GConf values */
-        if (bind_size) {
-                char *key;
-                GConfValue *width_val, *height_val, *maximized_val;
-
-                key = g_strconcat (key_prefix, "_width", NULL);
-                width_val = gconf_client_get (bridge->client, key, NULL);
-                g_free (key);
-
-                key = g_strconcat (key_prefix, "_height", NULL);
-                height_val = gconf_client_get (bridge->client, key, NULL);
-                g_free (key);
-
-                key = g_strconcat (key_prefix, "_maximized", NULL);
-                maximized_val = gconf_client_get (bridge->client, key, NULL);
-                g_free (key);
-
-                if (width_val && height_val) {
-                        gtk_window_resize (window,
-                                           gconf_value_get_int (width_val),
-                                           gconf_value_get_int (height_val));
-
-                        gconf_value_free (width_val);
-                        gconf_value_free (height_val);
-                } else if (width_val) {
-                        gconf_value_free (width_val);
-                } else if (height_val) {
-                        gconf_value_free (height_val);
-                }
-
-                if (maximized_val) {
-                        if (gconf_value_get_bool (maximized_val)) {
-                                gtk_window_maximize (window);
-                        }
-                        gconf_value_free (maximized_val);
-                }
-        }
-
-        if (bind_pos) {
-                char *key;
-                GConfValue *x_val, *y_val;
-                
-                key = g_strconcat (key_prefix, "_x", NULL);
-                x_val = gconf_client_get (bridge->client, key, NULL);
-                g_free (key);
-
-                key = g_strconcat (key_prefix, "_y", NULL);
-                y_val = gconf_client_get (bridge->client, key, NULL);
-                g_free (key);
-
-                if (x_val && y_val) {
-                        gtk_window_move (window,
-                                         gconf_value_get_int (x_val),
-                                         gconf_value_get_int (y_val));
-
-                        gconf_value_free (x_val);
-                        gconf_value_free (y_val);
-                } else if (x_val) {
-                        gconf_value_free (x_val);
-                } else if (y_val) {
-                        gconf_value_free (y_val);
-                }
-        }
-
-        /* Connect to window size change notifications */
-        binding->configure_event_id =
-                g_signal_connect (window,
-                                  "configure-event",
-                                  G_CALLBACK
-                                        (window_binding_configure_event_cb),
-                                  binding);
-
-        binding->configure_event_id =
-                g_signal_connect (window,
-                                  "window_state_event",
-                                  G_CALLBACK
-                                        (window_binding_state_event_cb),
-                                  binding);
-        binding->unmap_id =
-                g_signal_connect (window,
-                                  "unmap",
-                                  G_CALLBACK (window_binding_unmap_cb),
-                                  binding);
-
-        /* Handle case where window gets destroyed */
-        g_object_weak_ref (G_OBJECT (window),
-                           window_binding_window_destroyed, binding);
-
-        /* Insert binding */
-        g_hash_table_insert (bridge->bindings,
-                             GUINT_TO_POINTER (binding->id), binding);
-
-        /* Done */
-        return binding->id;
-}
-
-/* Unbinds a window binding */
-static void
-window_binding_unbind (WindowBinding *binding)
-{
-        if (binding->sync_timeout_id > 0)
-                g_source_remove (binding->sync_timeout_id);
-
-        g_free (binding->key_prefix);
-
-        /* The window might have been destroyed .. */
-        if (binding->window) {
-                g_signal_handler_disconnect (binding->window,
-                                             binding->configure_event_id);
-                g_signal_handler_disconnect (binding->window,
-                                             binding->unmap_id);
-
-                g_object_weak_unref (G_OBJECT (binding->window),
-                                     window_binding_window_destroyed, binding);
-        }
-}
-
-/*
- * List store bindings
- */
-
-/* Fills a GtkListStore with the string list from @value */
-static void
-list_store_binding_sync_pref_to_store (ListStoreBinding *binding,
-                                       GConfValue       *value)
-{
-        GSList *list, *l;
-        GtkTreeIter iter;
-
-        /* Make sure we don't enter an infinite synchronizing loop */
-        g_signal_handler_block (binding->list_store,
-                                binding->row_inserted_id);
-        g_signal_handler_block (binding->list_store,
-                                binding->row_deleted_id);
-        
-        gtk_list_store_clear (binding->list_store);
-
-        list = gconf_value_get_list (value);
-        for (l = list; l; l = l->next) {
-                GConfValue *l_value;
-                const char *string;
-
-                l_value = (GConfValue *) l->data;
-                string = gconf_value_get_string (l_value);
-
-                gtk_list_store_insert_with_values (binding->list_store,
-                                                   &iter, -1,
-                                                   0, string,
-                                                   -1);
-        }
-
-        g_signal_handler_unblock (binding->list_store,
-                                  binding->row_inserted_id);
-        g_signal_handler_unblock (binding->list_store,
-                                  binding->row_deleted_id);
-}
-
-/* Sets a GConf value to the contents of a GtkListStore */
-static gboolean
-list_store_binding_sync_store_to_pref (ListStoreBinding *binding)
-{
-        GtkTreeModel *tree_model;
-        GtkTreeIter iter;
-        GSList *list;
-        int res;
-        GConfValue *gconf_value;
-
-        tree_model = GTK_TREE_MODEL (binding->list_store);
-
-        /* Build list */
-        list = NULL;
-        res = gtk_tree_model_get_iter_first (tree_model, &iter);
-        while (res) {
-                char *string;
-                GConfValue *tmp_value;
-
-                gtk_tree_model_get (tree_model, &iter,
-                                    0, &string, -1);
-
-                tmp_value = gconf_value_new (GCONF_VALUE_STRING);
-                gconf_value_set_string (tmp_value, string);
-
-                list = g_slist_append (list, tmp_value);
-
-                res = gtk_tree_model_iter_next (tree_model, &iter);
-        }
-
-        /* Create value */
-        gconf_value = gconf_value_new (GCONF_VALUE_LIST);
-        gconf_value_set_list_type (gconf_value, GCONF_VALUE_STRING);
-        gconf_value_set_list_nocopy (gconf_value, list);
-
-        /* Set */
-        gconf_client_set (bridge->client, binding->key, gconf_value, NULL);
-
-        /* Store until change notification comes in, so that we are able
-         * to ignore it */
-        binding->val_changes = g_slist_append (binding->val_changes,
-                                               gconf_value);
-
-        binding->sync_idle_id = 0;
-
-        g_object_unref (binding->list_store);
-
-        return FALSE;
-}
-
-/* Pref changed: sync */
-static void
-list_store_binding_pref_changed (GConfClient *client,
-                                 guint        cnxn_id,
-                                 GConfEntry  *entry,
-                                 gpointer     user_data)
-{
-        GConfValue *gconf_value;
-        ListStoreBinding *binding;
-        GSList *l;
-
-        gconf_value = gconf_entry_get_value (entry);
-        if (!gconf_value)
-                return; /* NULL means that the value has been unset */
-
-        binding = (ListStoreBinding *) user_data;
-
-        /* Check that this notification is not caused by
-         * sync_store_to_pref() */
-        l = g_slist_find_custom (binding->val_changes,
-                                 gconf_value,
-                                 (GCompareFunc) gconf_value_compare);
-        if (l) {
-                gconf_value_free (l->data);
-
-                binding->val_changes = g_slist_delete_link
-                        (binding->val_changes, l);
-
-                return;
-        }
-
-        list_store_binding_sync_pref_to_store (binding, gconf_value);
-}
-
-/* Called when an object is destroyed */
-static void
-list_store_binding_store_destroyed (gpointer user_data,
-                                    GObject *where_the_object_was)
-{
-        ListStoreBinding *binding;
-
-        binding = (ListStoreBinding *) user_data;
-        binding->list_store = NULL; /* Don't do anything with the store
-                                       at unbind() */
-        
-        g_hash_table_remove (bridge->bindings,
-                             GUINT_TO_POINTER (binding->id));
-}
-
-/* List store changed: Sync */
-static void
-list_store_binding_store_changed_cb (ListStoreBinding *binding)
-{
-        if (binding->sync_idle_id == 0) {
-                g_object_ref (binding->list_store);
-
-                binding->sync_idle_id = g_idle_add
-                        ((GSourceFunc) list_store_binding_sync_store_to_pref,
-                         binding);
-        }
-}
-
-/**
- * gconf_bridge_bind_string_list_store
- * @bridge: A #GConfBridge
- * @key: A GConf key to be bound
- * @list_store: A #GtkListStore
- * 
- * On calling this function single string column #GtkListStore @list_store
- * will be kept synchronized with the GConf string list value pointed to by
- * @key. On calling this function @list_store will be populated with the
- * strings specified by the value of @key.
- *
- * Return value: The ID of the new binding.
- **/
-guint
-gconf_bridge_bind_string_list_store (GConfBridge  *bridge,
-                                     const char   *key,
-                                     GtkListStore *list_store)
-{
-        GtkTreeModel *tree_model;
-        gboolean have_one_column, is_string_column;
-        ListStoreBinding *binding;
-        GConfValue *val;
-
-        g_return_val_if_fail (bridge != NULL, 0);
-        g_return_val_if_fail (key != NULL, 0);
-        g_return_val_if_fail (GTK_IS_LIST_STORE (list_store), 0);
-
-        /* Check list store suitability */
-        tree_model = GTK_TREE_MODEL (list_store);
-        have_one_column = (gtk_tree_model_get_n_columns (tree_model) == 1);
-        is_string_column = (gtk_tree_model_get_column_type
-                                        (tree_model, 0) == G_TYPE_STRING);
-        if (G_UNLIKELY (!have_one_column || !is_string_column)) {
-                g_warning ("gconf_bridge_bind_string_list_store: Only "
-                           "GtkListStores with exactly one string column are "
-                           "supported.");
-
-                return 0;
-        }
-
-        /* Create new binding. */
-        binding = g_new (ListStoreBinding, 1);
-
-        binding->type = BINDING_LIST_STORE;
-        binding->id = new_id ();
-        binding->key = g_strdup (key);
-        binding->val_changes = NULL;
-        binding->list_store = list_store;
-        binding->sync_idle_id = 0;
-
-        /* Watch GConf key */
-        binding->val_notify_id =
-                gconf_client_notify_add (bridge->client, key,
-                                         list_store_binding_pref_changed,
-                                         binding, NULL, NULL);
-
-        /* Connect to ListStore change notifications */
-        binding->row_inserted_id =
-                g_signal_connect_swapped (list_store, "row-inserted",
-                                          G_CALLBACK
-                                          (list_store_binding_store_changed_cb),
-                                          binding);
-        binding->row_changed_id =
-                g_signal_connect_swapped (list_store, "row-inserted",
-                                          G_CALLBACK
-                                          (list_store_binding_store_changed_cb),
-                                          binding);
-        binding->row_deleted_id =
-                g_signal_connect_swapped (list_store, "row-inserted",
-                                          G_CALLBACK
-                                          (list_store_binding_store_changed_cb),
-                                          binding);
-        binding->rows_reordered_id =
-                g_signal_connect_swapped (list_store, "row-inserted",
-                                          G_CALLBACK
-                                          (list_store_binding_store_changed_cb),
-                                          binding);
-
-        /* Sync object to value from GConf, if set */
-        val = gconf_client_get (bridge->client, key, NULL);
-        if (val) {
-                list_store_binding_sync_pref_to_store (binding, val);
-                gconf_value_free (val);
-        }
-
-        /* Handle case where watched object gets destroyed */
-        g_object_weak_ref (G_OBJECT (list_store),
-                           list_store_binding_store_destroyed, binding);
-
-        /* Insert binding */
-        g_hash_table_insert (bridge->bindings,
-                             GUINT_TO_POINTER (binding->id), binding);
-
-        /* Done */
-        return binding->id;
-}
-
-/* Unbinds a list store binding */
-static void
-list_store_binding_unbind (ListStoreBinding *binding)
-{
-        /* Perform any scheduled syncs */
-        if (binding->sync_idle_id > 0) {
-                g_source_remove (binding->sync_idle_id);
-
-                /* The store will still be around as we added a reference */
-                list_store_binding_sync_store_to_pref (binding);
-        }
-
-        g_free (binding->key);
-
-        while (binding->val_changes) {
-                gconf_value_free (binding->val_changes->data);
-
-                binding->val_changes = g_slist_delete_link
-                        (binding->val_changes, binding->val_changes);
-        }
-
-        /* The store might have been destroyed .. */
-        if (binding->list_store) {
-                g_signal_handler_disconnect (binding->list_store,
-                                             binding->row_inserted_id);
-                g_signal_handler_disconnect (binding->list_store,
-                                             binding->row_changed_id);
-                g_signal_handler_disconnect (binding->list_store,
-                                             binding->row_deleted_id);
-                g_signal_handler_disconnect (binding->list_store,
-                                             binding->rows_reordered_id);
-
-                g_object_weak_unref (G_OBJECT (binding->list_store),
-                                     list_store_binding_store_destroyed,
-                                     binding);
-        }
-}
-
-/*
- * Generic unbinding
- */
-
-/* Unbinds a binding */
-static void
-unbind (Binding *binding)
-{
-        /* Call specialized unbinding function */
-        switch (binding->type) {
-        case BINDING_PROP:
-                prop_binding_unbind ((PropBinding *) binding);
-                break;
-        case BINDING_WINDOW:
-                window_binding_unbind ((WindowBinding *) binding);
-                break;
-        case BINDING_LIST_STORE:
-                list_store_binding_unbind ((ListStoreBinding *) binding);
-                break;
-        default:
-                g_warning ("Unknown binding type '%d'\n", binding->type);
-                break;
-        }
-
-        g_free (binding);
-}
-
-/**
- * gconf_bridge_unbind
- * @bridge: A #GConfBridge
- * @binding_id: The ID of the binding to be removed
- *
- * Removes the binding with ID @binding_id.
- **/
-void
-gconf_bridge_unbind (GConfBridge *bridge,
-                     guint        binding_id)
-{
-        g_return_if_fail (bridge != NULL);
-        g_return_if_fail (binding_id > 0);
-
-        /* This will trigger the hash tables value destruction
-         * function, which will take care of further cleanup */
-        g_hash_table_remove (bridge->bindings, 
-                             GUINT_TO_POINTER (binding_id));
-}
-
-/*
- * Error handling
- */
-
-/* This is the same dialog as used in eel */
-static void
-error_handler (GConfClient *client,
-               GError      *error)
-{
-        static gboolean shown_dialog = FALSE;
-
-        g_warning ("GConf error:\n  %s", error->message);
-
-        if (!shown_dialog) {
-                GtkWidget *dlg;
-
-                dlg = gtk_message_dialog_new (NULL, 0,
-                                              GTK_MESSAGE_ERROR,
-                                              GTK_BUTTONS_OK,
-                                              _("GConf error: %s"),
-                                              error->message);
-
-                gtk_message_dialog_format_secondary_text
-                        (GTK_MESSAGE_DIALOG (dlg),
-                         _("All further errors shown only on terminal."));
-                gtk_window_set_title (GTK_WINDOW (dlg), "");
-
-                gtk_dialog_run (GTK_DIALOG (dlg));
-
-                gtk_widget_destroy (dlg);
-
-                shown_dialog = TRUE;
-	}
-}
-
-/**
- * gconf_bridge_install_default_error_handler
- *
- * Sets up the default error handler. Any unhandled GConf errors will
- * automatically be handled by presenting the user an error dialog.
- **/
-void
-gconf_bridge_install_default_error_handler (void)
-{
-        gconf_client_set_global_default_error_handler (error_handler);
-}
diff --git a/src/gconf-bridge.h b/src/gconf-bridge.h
deleted file mode 100644
index ba67f4f..0000000
--- a/src/gconf-bridge.h
+++ /dev/null
@@ -1,116 +0,0 @@
-/* 
- * (C) 2005 OpenedHand Ltd.
- *
- * Author: Jorn Baayen <jorn@openedhand.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef __GCONF_BRIDGE_H__
-#define __GCONF_BRIDGE_H__
-
-#include <gconf/gconf-client.h>
-#include <gtk/gtk.h>
-
-G_BEGIN_DECLS
-
-void gconf_bridge_install_default_error_handler (void);
-
-typedef struct _GConfBridge GConfBridge;
-
-GConfBridge *gconf_bridge_get                    (void);
-
-GConfClient *gconf_bridge_get_client             (GConfBridge  *bridge);
-
-guint        gconf_bridge_bind_property_full     (GConfBridge  *bridge,
-                                                  const char   *key,
-                                                  GObject      *object,
-                                                  const char   *prop,
-                                                  gboolean      delayed_sync);
-
-/**
- * gconf_bridge_bind_property
- * @bridge: A #GConfBridge
- * @key: A GConf key to be bound
- * @object: A #GObject
- * @prop: The property of @object to be bound
- *
- * Binds @key to @prop without delays, causing them to have the same value at all times. See
- * #gconf_bridge_bind_property_full for more details.
- *
- **/
-#define gconf_bridge_bind_property(bridge, key, object, prop) \
-        gconf_bridge_bind_property_full ((bridge), (key), \
-                                         (object), (prop), FALSE)
-
-/**
- * gconf_bridge_bind_property_delayed
- * @bridge: A #GConfBridge
- * @key: A GConf key to be bound
- * @object: A #GObject
- * @prop: The property of @object to be bound
- *
- * Binds @key to @prop with a delay, causing them to have the same value at all
- * times. See #gconf_bridge_bind_property_full for more details.
- **/
-#define gconf_bridge_bind_property_delayed(bridge, key, object, prop) \
-        gconf_bridge_bind_property_full ((bridge), (key), \
-                                         (object), (prop), TRUE)
-
-guint        gconf_bridge_bind_window            (GConfBridge  *bridge,
-                                                  const char   *key_prefix,
-                                                  GtkWindow    *window,
-                                                  gboolean      bind_size,
-                                                  gboolean      bind_pos);
-
-/**
- * gconf_bridge_bind_window_size
- * @bridge: A #GConfBridge
- * @key_prefix: The prefix of the GConf keys
- * @window: A #GtkWindow
- * 
- * On calling this function @window will be resized to the values specified by
- * "@key_prefix<!-- -->_width" and "@key_prefix<!-- -->_height".  The respective
- * GConf values will be updated when the window is resized. See
- * #gconf_bridge_bind_window for more details.
- **/
-#define gconf_bridge_bind_window_size(bridge, key_prefix, window) \
-        gconf_bridge_bind_window ((bridge), (key_prefix), (window), TRUE, FALSE)
-
-/**
- * gconf_bridge_bind_window_pos
- * @bridge: A #GConfBridge
- * @key_prefix: The prefix of the GConf keys
- * @window: A #GtkWindow
- * 
- * On calling this function @window will be moved to the values specified by
- * "@key_prefix<!-- -->_x" and "@key_prefix<!-- -->_y". The respective GConf
- * values will be updated when the window is moved. See
- * #gconf_bridge_bind_window for more details.
- **/
-#define gconf_bridge_bind_window_pos(bridge, key_prefix, window) \
-        gconf_bridge_bind_window ((bridge), (key_prefix), (window), FALSE, TRUE)
-
-guint        gconf_bridge_bind_string_list_store (GConfBridge  *bridge,
-                                                  const char   *key,
-                                                  GtkListStore *list_store);
-
-void         gconf_bridge_unbind                 (GConfBridge  *bridge,
-                                                  guint         binding_id);
-
-G_END_DECLS
-
-#endif /* __GCONF_BRIDGE_H__ */
diff --git a/src/sj-extracting.c b/src/sj-extracting.c
index dab3dbd..0622a0e 100644
--- a/src/sj-extracting.c
+++ b/src/sj-extracting.c
@@ -134,12 +134,12 @@ static guint cookie;
 static GFile *
 build_filename (const TrackDetails *track, gboolean temp_filename, GError **error)
 {
-  GFile *uri, *new; 
+  GFile *uri, *new;
   gchar *realfile, *realpath, *filename, *scheme;
   const gchar *extension;
   size_t len_extension;
   int max_realfile = INT_MAX;
-  GMAudioProfile *profile;
+  GstEncodingProfile *profile;
 
   g_object_get (extractor, "profile", &profile, NULL);
 
@@ -152,7 +152,11 @@ build_filename (const TrackDetails *track, gboolean temp_filename, GError **erro
     g_set_error (error, 0, 0, _("Failed to get output format"));
     return NULL;
   } else {
-      extension = gm_audio_profile_get_extension (profile);
+      gchar *media_type;
+      media_type = rb_gst_encoding_profile_get_media_type (profile);
+      extension = rb_gst_media_type_to_extension (media_type);
+      g_free (media_type);
+      gst_encoding_profile_unref (profile);
   }
 
   len_extension = 1 + strlen (extension);
diff --git a/src/sj-main.c b/src/sj-main.c
index 1a1e5f5..ea99d53 100644
--- a/src/sj-main.c
+++ b/src/sj-main.c
@@ -34,14 +34,13 @@
 #include <gdk/gdkkeysyms.h>
 #include <gio/gio.h>
 #include <gtk/gtk.h>
-#include <gconf/gconf-client.h>
 #include <brasero-medium-selection.h>
 #include <brasero-volume.h>
-#include <libgnome-media-profiles/gnome-media-profiles.h>
 #include <gst/gst.h>
+#include <gst/pbutils/encoding-profile.h>
 
 #include "bacon-message-connection.h"
-#include "gconf-bridge.h"
+#include "rb-gst-media-types.h"
 #include "sj-about.h"
 #include "sj-metadata-getter.h"
 #include "sj-extractor.h"
@@ -70,7 +69,7 @@ GtkBuilder *builder;
 SjMetadataGetter *metadata;
 SjExtractor *extractor;
 
-GConfClient *gconf_client;
+GSettings *sj_settings;
 
 GtkWidget *main_window;
 static GtkWidget *message_area_eventbox;
@@ -86,7 +85,8 @@ GtkCellRenderer *toggle_renderer, *title_renderer, *artist_renderer;
 
 GtkWidget *current_message_area;
 
-const char *path_pattern, *file_pattern;
+char *path_pattern = NULL;
+char *file_pattern = NULL;
 GFile *base_uri;
 BraseroDrive *drive = NULL;
 gboolean strip_chars;
@@ -675,120 +675,96 @@ AlbumDetails* multiple_album_dialog(GList *albums)
 }
 
 /**
- * The GConf key for the base path changed
+ * The GSettings key for the base path changed
  */
-static void baseuri_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void baseuri_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
-  g_assert (strcmp (entry->key, GCONF_BASEURI) == 0);
+  gchar *value;
+  g_assert (strcmp (key, SJ_SETTINGS_BASEURI) == 0);
   if (base_uri) {
     g_object_unref (base_uri);
   }
-  if (entry->value == NULL) {
+  value = g_settings_get_string (settings, key);
+  if ((value == NULL) || (*value == '\0')) {
     base_uri = sj_get_default_music_directory ();
   } else {
-    base_uri = g_file_new_for_uri (gconf_value_get_string (entry->value));
+    base_uri = g_file_new_for_uri (value);
   }
+  g_free (value);
   /* TODO: sanity check the URI somewhat */
 }
 
 /**
- * The GConf key for the directory pattern changed
+ * The GSettings key for the directory pattern changed
  */
-static void path_pattern_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void path_pattern_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
-  g_assert (strcmp (entry->key, GCONF_PATH_PATTERN) == 0);
-  if (entry->value == NULL) {
-    /* TODO: this value and the value in sj-prefs need to be in one place */
-    path_pattern = g_strdup ("%aa/%at");
-  } else {
-    path_pattern = gconf_value_get_string (entry->value);
-  }
+  g_assert (strcmp (key, SJ_SETTINGS_PATH_PATTERN) == 0);
+  g_free (path_pattern);
+  path_pattern = g_settings_get_string (settings, key);
   /* TODO: sanity check the pattern */
 }
 
 /**
- * The GConf key for the filename pattern changed
+ * The GSettings key for the filename pattern changed
  */
-static void file_pattern_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void file_pattern_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
-  g_assert (strcmp (entry->key, GCONF_FILE_PATTERN) == 0);
-  if (entry->value == NULL) {
-    /* TODO: this value and the value in sj-prefs need to be in one place */
-    file_pattern = g_strdup ("%tN-%tt");
-  } else {
-    file_pattern = gconf_value_get_string (entry->value);
-  }
+  g_assert (strcmp (key, SJ_SETTINGS_FILE_PATTERN) == 0);
+  g_free (file_pattern);
+  file_pattern = g_settings_get_string (settings, key);
   /* TODO: sanity check the pattern */
 }
 
 /**
- * The GConf key for the paranoia mode has changed
+ * The GSettings key for the paranoia mode has changed
  */
-static void paranoia_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void paranoia_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
-  g_assert (strcmp (entry->key, GCONF_PARANOIA) == 0);
-  if (entry->value == NULL) {
-    sj_extractor_set_paranoia (extractor, DEFAULT_PARANOIA);
-  } else {
-    int value = gconf_value_get_int (entry->value);
-    if (value == 0 || value == 2 || value == 4 || value == 8 || value == 16 || value == 255) {
-      sj_extractor_set_paranoia (extractor, value);
-    }
+  int value;
+  g_assert (strcmp (key, SJ_SETTINGS_PARANOIA) == 0);
+  value = g_settings_get_int (settings, key);
+  if (value == 0 || value == 2 || value == 4 || value == 8 || value == 16 || value == 255) {
+    sj_extractor_set_paranoia (extractor, value);
   }
 }
 
 /**
- * The GConf key for the strip characters option changed
+ * The GSettings key for the strip characters option changed
  */
-static void strip_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void strip_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
-  g_assert (strcmp (entry->key, GCONF_STRIP) == 0);
-  if (entry->value == NULL) {
-    strip_chars = FALSE;
-  } else {
-    strip_chars = gconf_value_get_bool (entry->value);
-  }
+  g_assert (strcmp (key, SJ_SETTINGS_STRIP) == 0);
+  strip_chars = g_settings_get_boolean (settings, key);
 }
 
 /**
- * The GConf key for the eject when finished option changed
+ * The GSettings key for the eject when finished option changed
  */
-static void eject_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void eject_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
-  g_assert (strcmp (entry->key, GCONF_EJECT) == 0);
-  if (entry->value == NULL) {
-    eject_finished = FALSE;
-  } else {
-    eject_finished = gconf_value_get_bool (entry->value);
-  }
+  g_assert (strcmp (key, SJ_SETTINGS_EJECT) == 0);
+  eject_finished = g_settings_get_boolean (settings, key);
 }
 
 /**
- * The GConf key for the open when finished option changed
+ * The GSettings key for the open when finished option changed
  */
-static void open_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void open_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
-  g_assert (strcmp (entry->key, GCONF_OPEN) == 0);
-  if (entry->value == NULL) {
-    open_finished = FALSE;
-  } else {
-    open_finished = gconf_value_get_bool (entry->value);
-  }
+  g_assert (strcmp (key, SJ_SETTINGS_OPEN) == 0);
+  open_finished = g_settings_get_boolean (settings, key);
 }
 
 /**
- * The GConf key for audio volume changes
+ * The GSettings key for audio volume changes
  */
-static void audio_volume_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void audio_volume_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
-  g_assert (strcmp (entry->key, GCONF_AUDIO_VOLUME) == 0);
+  g_assert (strcmp (key, SJ_SETTINGS_AUDIO_VOLUME) == 0);
 
   GtkWidget *volb = GET_WIDGET ("volume_button");
-  if (entry->value == NULL) {
-    gtk_scale_button_set_value (GTK_SCALE_BUTTON (volb), 1.0);
-  } else {
-    gtk_scale_button_set_value (GTK_SCALE_BUTTON (volb), gconf_value_get_float (entry->value));
-  }
+  gtk_scale_button_set_value (GTK_SCALE_BUTTON (volb), g_settings_get_double (settings, key));
 }
 
 static void
@@ -1099,15 +1075,17 @@ prefs_get_default_device (void)
 }
 
 /**
- * The GConf key for the device changed
+ * The GSettings key for the device changed
  */
-static void device_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void device_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
   const char *device;
+  char *value;
   gboolean ignore_no_media = GPOINTER_TO_INT (user_data);
-  g_assert (strcmp (entry->key, GCONF_DEVICE) == 0);
+  g_assert (strcmp (key, SJ_SETTINGS_DEVICE) == 0);
 
-  if (entry->value == NULL || !cd_drive_exists (gconf_value_get_string (entry->value))) {
+  value = g_settings_get_string (settings, key);
+  if (!cd_drive_exists (value)) {
     device = prefs_get_default_device();
     if (device == NULL) {
 #ifndef IGNORE_MISSING_CD
@@ -1125,18 +1103,21 @@ static void device_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *e
 #endif
     }
   } else {
-    device = gconf_value_get_string (entry->value);
+    device = value;
   }
   set_device (device, ignore_no_media);
+  g_free (value);
 }
 
-static void profile_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void profile_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
-  GMAudioProfile *profile;
+  GstEncodingProfile *profile;
+  char *media_type;
 
-  g_assert (strcmp (entry->key, GCONF_AUDIO_PROFILE) == 0);
-  if (!entry->value) return;
-  profile = gm_audio_profile_lookup (gconf_value_get_string (entry->value));
+  g_assert (strcmp (key, SJ_SETTINGS_AUDIO_PROFILE) == 0);
+  media_type = g_settings_get_string (settings, key);
+  profile = rb_gst_get_encoding_profile (media_type);
+  g_free (media_type);
   if (profile != NULL)
     g_object_set (extractor, "profile", profile, NULL);
 
@@ -1160,56 +1141,56 @@ static void profile_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *
       exit(0);
     }
   }
+
+  if (profile != NULL)
+    gst_encoding_profile_unref (profile);
 }
 
 /**
  * Configure the http proxy
  */
 static void
-http_proxy_setup (GConfClient *client)
+http_proxy_setup (GSettings *settings)
 {
-  if (!gconf_client_get_bool (client, GCONF_HTTP_PROXY_ENABLE, NULL)) {
+  if (!g_settings_get_boolean (settings, SJ_SETTINGS_HTTP_PROXY_ENABLE)) {
     sj_metadata_getter_set_proxy (metadata, NULL);
   } else {
     char *host;
     int port;
 
-    host = gconf_client_get_string (client, GCONF_HTTP_PROXY, NULL);
+    host = g_settings_get_string (settings, SJ_SETTINGS_HTTP_PROXY);
     sj_metadata_getter_set_proxy (metadata, host);
     g_free (host);
-    port = gconf_client_get_int (client, GCONF_HTTP_PROXY_PORT, NULL);
+    port = g_settings_get_int (settings, SJ_SETTINGS_HTTP_PROXY_PORT);
     sj_metadata_getter_set_proxy_port (metadata, port);
   }
 }
 
 /**
- * The GConf key for the HTTP proxy being enabled changed.
+ * The GSettings key for the HTTP proxy being enabled changed.
  */
-static void http_proxy_enable_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void http_proxy_enable_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
-  g_assert (strcmp (entry->key, GCONF_HTTP_PROXY_ENABLE) == 0);
-  if (entry->value == NULL) return;
-  http_proxy_setup (client);
+  g_assert (strcmp (key, SJ_SETTINGS_HTTP_PROXY_ENABLE) == 0);
+  http_proxy_setup (settings);
 }
 
 /**
- * The GConf key for the HTTP proxy changed.
+ * The GSettings key for the HTTP proxy changed.
  */
-static void http_proxy_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void http_proxy_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
-  g_assert (strcmp (entry->key, GCONF_HTTP_PROXY) == 0);
-  if (entry->value == NULL) return;
-  http_proxy_setup (client);
+  g_assert (strcmp (key, SJ_SETTINGS_HTTP_PROXY) == 0);
+  http_proxy_setup (settings);
 }
 
 /**
- * The GConf key for the HTTP proxy port changed.
+ * The GSettings key for the HTTP proxy port changed.
  */
-static void http_proxy_port_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void http_proxy_port_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
-  g_assert (strcmp (entry->key, GCONF_HTTP_PROXY_PORT) == 0);
-  if (entry->value == NULL) return;
-  http_proxy_setup (client);
+  g_assert (strcmp (key, SJ_SETTINGS_HTTP_PROXY_PORT) == 0);
+  http_proxy_setup (settings);
 }
 
 /**
@@ -1498,28 +1479,6 @@ G_MODULE_EXPORT void on_contents_activate(GtkWidget *button, gpointer user_data)
 }
 
 static void
-upgrade_gconf (void)
-{
-  char *s;
-  s = gconf_client_get_string (gconf_client, GCONF_BASEURI, NULL);
-  if (s != NULL) {
-    g_free (s);
-  } else {
-    GFile *gfile;
-    char *uri;
-    s = gconf_client_get_string (gconf_client, GCONF_BASEPATH, NULL);
-    if (s == NULL)
-      return;
-    gfile = g_file_new_for_path (s);
-    uri = g_file_get_uri (gfile);
-    g_free (s);
-    g_object_unref (gfile);
-    gconf_client_set_string (gconf_client, GCONF_BASEURI, uri, NULL);
-    g_free (uri);
-  }
-}
-
-static void
 on_message_received (const char *message, gpointer user_data)
 {
   if (message == NULL)
@@ -1625,6 +1584,7 @@ int main (int argc, char **argv)
     { G_OPTION_REMAINING, '\0', 0, G_OPTION_ARG_FILENAME_ARRAY, &uris, N_("URI to the CD device to read"), NULL },
     { NULL }
   };
+  GSettings *http_settings;
 
   if (!g_thread_supported ()) g_thread_init (NULL);
 
@@ -1670,32 +1630,44 @@ int main (int argc, char **argv)
   metadata = sj_metadata_getter_new ();
   g_signal_connect (metadata, "metadata", G_CALLBACK (metadata_cb), NULL);
 
-  gconf_client = gconf_client_get_default ();
-  if (gconf_client == NULL) {
-    g_warning (_("Could not create GConf client.\n"));
+  sj_settings = g_settings_new ("org.gnome.SoundJuicer");
+  if (sj_settings == NULL) {
+    g_warning (_("Could not create GSettings object.\n"));
     exit (1);
   }
 
-  upgrade_gconf ();
-
-  gconf_client_add_dir (gconf_client, GCONF_ROOT, GCONF_CLIENT_PRELOAD_RECURSIVE, NULL);
-  gconf_client_notify_add (gconf_client, GCONF_DEVICE, device_changed_cb, NULL, NULL, NULL);
-  gconf_client_notify_add (gconf_client, GCONF_EJECT, eject_changed_cb, NULL, NULL, NULL);
-  gconf_client_notify_add (gconf_client, GCONF_OPEN, open_changed_cb, NULL, NULL, NULL);
-  gconf_client_notify_add (gconf_client, GCONF_BASEURI, baseuri_changed_cb, NULL, NULL, NULL);
-  gconf_client_notify_add (gconf_client, GCONF_STRIP, strip_changed_cb, NULL, NULL, NULL);
-  gconf_client_notify_add (gconf_client, GCONF_AUDIO_PROFILE, profile_changed_cb, NULL, NULL, NULL);
-  gconf_client_notify_add (gconf_client, GCONF_PARANOIA, paranoia_changed_cb, NULL, NULL, NULL);
-  gconf_client_notify_add (gconf_client, GCONF_PATH_PATTERN, path_pattern_changed_cb, NULL, NULL, NULL);
-  gconf_client_notify_add (gconf_client, GCONF_FILE_PATTERN, file_pattern_changed_cb, NULL, NULL, NULL);
-  gconf_client_notify_add (gconf_client, GCONF_AUDIO_VOLUME, audio_volume_changed_cb, NULL, NULL, NULL);
-  gconf_client_add_dir (gconf_client, GCONF_PROXY_ROOT, GCONF_CLIENT_PRELOAD_RECURSIVE, NULL);
-  gconf_client_notify_add (gconf_client, GCONF_HTTP_PROXY_ENABLE, http_proxy_enable_changed_cb, NULL, NULL, NULL);
-  gconf_client_notify_add (gconf_client, GCONF_HTTP_PROXY, http_proxy_changed_cb, NULL, NULL, NULL);
-  gconf_client_notify_add (gconf_client, GCONF_HTTP_PROXY_PORT, http_proxy_port_changed_cb, NULL, NULL, NULL);
-
-  /* init gnome-media-profiles */
-  gnome_media_profiles_init (gconf_client);
+  g_signal_connect (sj_settings, "changed::"SJ_SETTINGS_DEVICE,
+                    (GCallback)device_changed_cb, NULL);
+  g_signal_connect (sj_settings, "changed::"SJ_SETTINGS_EJECT,
+                    (GCallback)eject_changed_cb, NULL);
+  g_signal_connect (sj_settings, "changed::"SJ_SETTINGS_OPEN,
+                    (GCallback)open_changed_cb, NULL);
+  g_signal_connect (sj_settings, "changed::"SJ_SETTINGS_BASEURI,
+                    (GCallback)baseuri_changed_cb, NULL);
+  g_signal_connect (sj_settings, "changed::"SJ_SETTINGS_STRIP,
+                    (GCallback)strip_changed_cb, NULL);
+  g_signal_connect (sj_settings, "changed::"SJ_SETTINGS_AUDIO_PROFILE,
+                    (GCallback)profile_changed_cb, NULL);
+  g_signal_connect (sj_settings, "changed::"SJ_SETTINGS_PARANOIA,
+                    (GCallback)paranoia_changed_cb, NULL);
+  g_signal_connect (sj_settings, "changed::"SJ_SETTINGS_PATH_PATTERN,
+                    (GCallback)path_pattern_changed_cb, NULL);
+  g_signal_connect (sj_settings, "changed::"SJ_SETTINGS_FILE_PATTERN,
+                    (GCallback)file_pattern_changed_cb, NULL);
+  g_signal_connect (sj_settings, "changed::"SJ_SETTINGS_AUDIO_VOLUME,
+                    (GCallback)audio_volume_changed_cb, NULL);
+
+  http_settings = g_settings_new ("org.gnome.system.proxy.http");
+  if (http_settings == NULL) {
+    g_warning (_("Could not create GSettings object.\n"));
+    exit (1);
+  }
+  g_signal_connect (http_settings, "changed::"SJ_SETTINGS_HTTP_PROXY_ENABLE,
+                    (GCallback)http_proxy_enable_changed_cb, NULL);
+  g_signal_connect (http_settings, "changed::"SJ_SETTINGS_HTTP_PROXY,
+                    (GCallback)http_proxy_changed_cb, NULL);
+  g_signal_connect (http_settings, "changed::"SJ_SETTINGS_HTTP_PROXY_PORT,
+                    (GCallback)http_proxy_port_changed_cb, NULL);
 
   builder = gtk_builder_new ();
   if (g_file_test (SOURCE_BUILDER, G_FILE_TEST_EXISTS) != FALSE) {
@@ -1830,18 +1802,22 @@ int main (int argc, char **argv)
   selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (track_listview));
   gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);
 
-  http_proxy_setup (gconf_client);
-  baseuri_changed_cb (gconf_client, -1, gconf_client_get_entry (gconf_client, GCONF_BASEURI, NULL, TRUE, NULL), NULL);
-  path_pattern_changed_cb (gconf_client, -1, gconf_client_get_entry (gconf_client, GCONF_PATH_PATTERN, NULL, TRUE, NULL), NULL);
-  file_pattern_changed_cb (gconf_client, -1, gconf_client_get_entry (gconf_client, GCONF_FILE_PATTERN, NULL, TRUE, NULL), NULL);
-  profile_changed_cb (gconf_client, -1, gconf_client_get_entry (gconf_client, GCONF_AUDIO_PROFILE, NULL, TRUE, NULL), NULL);
-  paranoia_changed_cb (gconf_client, -1, gconf_client_get_entry (gconf_client, GCONF_PARANOIA, NULL, TRUE, NULL), NULL);
-  strip_changed_cb (gconf_client, -1, gconf_client_get_entry (gconf_client, GCONF_STRIP, NULL, TRUE, NULL), NULL);
-  eject_changed_cb (gconf_client, -1, gconf_client_get_entry (gconf_client, GCONF_EJECT, NULL, TRUE, NULL), NULL);
-  open_changed_cb (gconf_client, -1, gconf_client_get_entry (gconf_client, GCONF_OPEN, NULL, TRUE, NULL), NULL);
-  audio_volume_changed_cb (gconf_client, -1, gconf_client_get_entry (gconf_client, GCONF_AUDIO_VOLUME, NULL, TRUE, NULL), NULL);
+  http_proxy_setup (http_settings);
+  baseuri_changed_cb (sj_settings, SJ_SETTINGS_BASEURI, NULL);
+  path_pattern_changed_cb (sj_settings, SJ_SETTINGS_PATH_PATTERN, NULL);
+  file_pattern_changed_cb (sj_settings, SJ_SETTINGS_FILE_PATTERN, NULL);
+  profile_changed_cb (sj_settings, SJ_SETTINGS_AUDIO_PROFILE, NULL);
+  paranoia_changed_cb (sj_settings, SJ_SETTINGS_PARANOIA, NULL);
+  strip_changed_cb (sj_settings, SJ_SETTINGS_STRIP, NULL);
+  eject_changed_cb (sj_settings, SJ_SETTINGS_EJECT, NULL);
+  open_changed_cb (sj_settings, SJ_SETTINGS_OPEN, NULL);
+  audio_volume_changed_cb (sj_settings, SJ_SETTINGS_AUDIO_VOLUME, NULL);
   if (device == NULL && uris == NULL) {
-    device_changed_cb (gconf_client, -1, gconf_client_get_entry (gconf_client, GCONF_DEVICE, NULL, TRUE, NULL), GINT_TO_POINTER (TRUE));
+    /* FIXME: this should set the device gsettings key to a meaningful
+     * value if it's empty (which is the case until the user changes it in
+     * the prefs)
+     */
+    device_changed_cb (sj_settings, SJ_SETTINGS_DEVICE, NULL);
   } else {
     if (device)
       set_device (device, TRUE);
@@ -1859,7 +1835,7 @@ int main (int argc, char **argv)
 	set_device (d, TRUE);
 	g_free (d);
       } else {
-        device_changed_cb (gconf_client, -1, gconf_client_get_entry (gconf_client, GCONF_DEVICE, NULL, TRUE, NULL), GINT_TO_POINTER (TRUE));
+        device_changed_cb (sj_settings, SJ_SETTINGS_DEVICE, NULL);
       }
     }
   }
@@ -1873,14 +1849,15 @@ int main (int argc, char **argv)
   gtk_widget_set_sensitive (duplicate, FALSE);
   duplication_enabled = is_cd_duplication_available();
 
-  gconf_bridge_bind_window_size(gconf_bridge_get(), GCONF_WINDOW, GTK_WINDOW (main_window));
+  /*gconf_bridge_bind_window_size(gconf_bridge_get(), GCONF_WINDOW, GTK_WINDOW (main_window)); */
   gtk_widget_show (main_window);
   gtk_main ();
 
   g_object_unref (base_uri);
   g_object_unref (metadata);
   g_object_unref (extractor);
-  g_object_unref (gconf_client);
+  g_object_unref (sj_settings);
+  g_object_unref (http_settings);
   brasero_media_library_stop ();
 
   return 0;
diff --git a/src/sj-play.c b/src/sj-play.c
index b6006f6..6ba0fbe 100644
--- a/src/sj-play.c
+++ b/src/sj-play.c
@@ -388,7 +388,7 @@ setup (GError **err)
     resample = gst_element_factory_make ("audioresample", "resample"); g_assert (resample);
     volume = gst_element_factory_make ("volume", "vol"); g_assert (volume);
     g_object_set (G_OBJECT (volume), "volume", vol, NULL);
-    out = gst_element_factory_make ("gconfaudiosink", "out");
+    out = gst_element_factory_make ("gsettingsaudiosink", "out");
     if (!out) {
         /* fall back to autoaudiosink */
         out = gst_element_factory_make ("autoaudiosink", "out");
@@ -583,8 +583,8 @@ on_volume_changed (GtkWidget * volb, gdouble value, gpointer data)
 
     volume = gst_bin_get_by_name_recurse_up (GST_BIN (pipeline), "vol");
     g_object_set (G_OBJECT (volume), "volume", vol, NULL);
-  }  
-  gconf_client_set_float (gconf_client, GCONF_AUDIO_VOLUME, vol, NULL);
+  }
+  g_settings_set_double (sj_settings, SJ_SETTINGS_AUDIO_VOLUME, vol);
 }
 
 /*
diff --git a/src/sj-prefs.c b/src/sj-prefs.c
index 10dd220..e323a4b 100644
--- a/src/sj-prefs.c
+++ b/src/sj-prefs.c
@@ -27,13 +27,12 @@
 #include "sound-juicer.h"
 
 #include <string.h>
+#include <gst/pbutils/encoding-profile.h>
 #include <gtk/gtk.h>
-#include <gconf/gconf-client.h>
-#include <libgnome-media-profiles/gnome-media-profiles.h>
 #include <brasero-drive-selection.h>
 
+#include "rb-gst-media-types.h"
 #include "sj-util.h"
-#include "gconf-bridge.h"
 #include "sj-extracting.h"
 #include "sj-prefs.h"
 
@@ -44,8 +43,6 @@ static GtkWidget *audio_profile;
 static GtkWidget *cd_option, *path_option, *file_option, *basepath_fcb, *check_strip, *check_eject, *check_open;
 static GtkWidget *path_example_label;
 
-#define DEFAULT_AUDIO_PROFILE_NAME "cdlossy"
-
 typedef struct {
   char* name;
   char* pattern;
@@ -79,12 +76,17 @@ static const FilePattern file_patterns[] = {
 
 void prefs_profile_changed (GtkWidget *widget, gpointer user_data)
 {
-  GMAudioProfile *profile;
+  GtkTreeIter iter;
+  GtkTreeModel *model;
+
+  model = gtk_combo_box_get_model (GTK_COMBO_BOX (widget));
   /* Handle the change being to unselect a profile */
-  if (gtk_combo_box_get_active (GTK_COMBO_BOX (widget)) != -1) {
-    profile = gm_audio_profile_choose_get_active (widget);
-    gconf_client_set_string (gconf_client, GCONF_AUDIO_PROFILE,  
-                             gm_audio_profile_get_id (profile), NULL);
+  if (gtk_combo_box_get_active_iter (GTK_COMBO_BOX (widget), &iter)) {
+    char *media_type;
+    gtk_tree_model_get (GTK_TREE_MODEL (model), &iter,
+                        0, &media_type, -1);
+    g_settings_set_string (sj_settings, SJ_SETTINGS_AUDIO_PROFILE, media_type);
+    g_free (media_type);
   }
 }
 
@@ -121,11 +123,11 @@ G_MODULE_EXPORT void prefs_base_folder_changed (GtkWidget *chooser, gpointer use
 {
   char *new_uri, *current_uri;
   
-  current_uri = gconf_client_get_string (gconf_client, GCONF_BASEURI, NULL);
+  current_uri = g_settings_get_string (sj_settings, SJ_SETTINGS_BASEURI);
   new_uri = gtk_file_chooser_get_uri (GTK_FILE_CHOOSER (chooser)); 
 
   if (current_uri == NULL || strcmp(current_uri, new_uri) != 0) {
-      gconf_client_set_string (gconf_client, GCONF_BASEURI, new_uri, NULL);
+      g_settings_set_string (sj_settings, SJ_SETTINGS_BASEURI, new_uri);
   }
   
   g_free (new_uri);
@@ -142,7 +144,7 @@ void prefs_path_option_changed (GtkComboBox *combo, gpointer user_data)
 
   pattern = path_patterns[active].pattern;
   if (pattern) {
-    gconf_client_set_string (gconf_client, GCONF_PATH_PATTERN, pattern, NULL);
+    g_settings_set_string (sj_settings, SJ_SETTINGS_PATH_PATTERN, pattern);
   }
 }
 
@@ -156,7 +158,7 @@ G_MODULE_EXPORT void prefs_file_option_changed (GtkComboBox *combo, gpointer use
 
   pattern = file_patterns[active].pattern;
   if (pattern) {
-    gconf_client_set_string (gconf_client, GCONF_FILE_PATTERN, pattern, NULL);
+    g_settings_set_string (sj_settings, SJ_SETTINGS_FILE_PATTERN, pattern);
   }
 }
 
@@ -165,28 +167,46 @@ G_MODULE_EXPORT void prefs_file_option_changed (GtkComboBox *combo, gpointer use
  */
 G_MODULE_EXPORT void prefs_edit_profile_clicked (GtkButton *button, gpointer user_data)
 {
-  GtkWidget *dialog;
-  dialog = gm_audio_profiles_edit_new (gconf_client, GTK_WINDOW (main_window));
-  gtk_widget_show_all (dialog);
-  gtk_dialog_run (GTK_DIALOG (dialog));
+    /* Not implemented */
 }
 
-static void audio_profile_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void
+sj_audio_profile_chooser_set_active (GtkWidget *chooser, const char *profile)
 {
-  const char *value;
-  g_return_if_fail (strcmp (entry->key, GCONF_AUDIO_PROFILE) == 0);
-  if (!entry->value) return;
-  value = gconf_value_get_string (entry->value);
-  
-  /* If the value is empty, unset the combo. Otherwise try and set it. */
-  if (strcmp (value, "") == 0) {
-    gtk_combo_box_set_active (GTK_COMBO_BOX (audio_profile), -1);
-  } else {
-    gm_audio_profile_choose_set_active (audio_profile, value);
+  GtkTreeIter iter;
+  GtkTreeModel *model;
+  gboolean done;
+
+  done = FALSE;
+  model = gtk_combo_box_get_model(GTK_COMBO_BOX(chooser));
+  if (gtk_tree_model_get_iter_first (model, &iter)) {
+    do {
+      char *media_type;
+
+      gtk_tree_model_get (model, &iter, 0, &media_type, -1);
+      if (g_strcmp0 (media_type, profile) == 0) {
+        gtk_combo_box_set_active_iter (GTK_COMBO_BOX (chooser), &iter);
+        done = TRUE;
+      }
+      g_free (media_type);
+    } while (done == FALSE && gtk_tree_model_iter_next (model, &iter));
+  }
+
+  if (done == FALSE) {
+    gtk_combo_box_set_active_iter (GTK_COMBO_BOX (chooser), NULL);
   }
 }
 
-static void baseuri_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void audio_profile_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
+{
+  char *value;
+  g_return_if_fail (strcmp (key, SJ_SETTINGS_AUDIO_PROFILE) == 0);
+  value = g_settings_get_string (settings, key);
+  sj_audio_profile_chooser_set_active (audio_profile, value);
+  g_free (value);
+}
+
+static void baseuri_changed_cb  (GSettings *settings, gchar *key, gpointer user_data)
 {
   /*
    * The conflict between separation of the prefs and the main window,
@@ -196,11 +216,9 @@ static void baseuri_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *
    * into sj-utils?
    */
   const char* base_uri, *current_uri;
-  g_return_if_fail (strcmp (entry->key, GCONF_BASEURI) == 0);
+  g_return_if_fail (strcmp (key, SJ_SETTINGS_BASEURI) == 0);
 
-  base_uri = NULL;
-  if (entry->value != NULL)
-    base_uri = gconf_value_get_string (entry->value);
+  base_uri = g_settings_get_string (settings, key);
 
   if (base_uri == NULL || base_uri[0] == '\0') {
     GFile *dir;
@@ -212,7 +230,6 @@ static void baseuri_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *
     g_free (dir_uri);
     g_object_unref (dir);
   } else {
-    g_return_if_fail (entry->value->type == GCONF_VALUE_STRING);
     current_uri = gtk_file_chooser_get_current_folder_uri (GTK_FILE_CHOOSER (basepath_fcb));
     if (current_uri == NULL || strcmp (current_uri, base_uri) != 0) 
       gtk_file_chooser_set_current_folder_uri (GTK_FILE_CHOOSER (basepath_fcb), base_uri);
@@ -224,7 +241,8 @@ static void pattern_label_update (void)
 {
   char *file_pattern, *path_pattern;
   char *file_value, *path_value, *example, *format;
-  GMAudioProfile *profile;
+  char *media_type;
+  GstEncodingProfile *profile;
 
   static const AlbumDetails sample_album = {
     "Help!", /* title */
@@ -254,13 +272,15 @@ static void pattern_label_update (void)
   if (!profile) {
     return;
   }
+  media_type = rb_gst_encoding_profile_get_media_type (profile);
+  gst_encoding_profile_unref (profile);
 
   /* TODO: sucky. Replace with get-gconf-key-with-default mojo */
-  file_pattern = gconf_client_get_string (gconf_client, GCONF_FILE_PATTERN, NULL);
+  file_pattern = g_settings_get_string (sj_settings, SJ_SETTINGS_FILE_PATTERN);
   if (file_pattern == NULL) {
     file_pattern = g_strdup(file_patterns[0].pattern);
   }
-  path_pattern = gconf_client_get_string (gconf_client, GCONF_PATH_PATTERN, NULL);
+  path_pattern = g_settings_get_string (sj_settings, SJ_SETTINGS_PATH_PATTERN);
   if (path_pattern == NULL) {
     path_pattern = g_strdup(path_patterns[0].pattern);
   }
@@ -279,26 +299,22 @@ static void pattern_label_update (void)
                         ":</b> ",
                         example,
                         ".",
-                        gm_audio_profile_get_extension (profile),
+                        rb_gst_media_type_to_extension (media_type),
                         "</i></small>", NULL);
   g_free (example);
+  g_free (media_type);
   
   gtk_label_set_markup (GTK_LABEL (path_example_label), format);
   g_free (format);
 }
 
-static void path_pattern_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void path_pattern_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
   char *value;
   int i = 0;
-  g_return_if_fail (strcmp (entry->key, GCONF_PATH_PATTERN) == 0);
+  g_return_if_fail (strcmp (key, SJ_SETTINGS_PATH_PATTERN) == 0);
 
-  if (entry->value == NULL) {
-    value = g_strdup (path_patterns[0].pattern);
-  } else if (entry->value->type == GCONF_VALUE_STRING) {
-    value = g_strdup (gconf_value_get_string (entry->value));
-  } else
-    return;
+  value = g_settings_get_string (settings, key);
   while (path_patterns[i].pattern && strcmp(path_patterns[i].pattern, value) != 0) {
     i++;
   }
@@ -307,19 +323,14 @@ static void path_pattern_changed_cb (GConfClient *client, guint cnxn_id, GConfEn
   pattern_label_update ();
 }
 
-static void file_pattern_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void file_pattern_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
   char *value;
   int i = 0;
-  
-  g_return_if_fail (strcmp (entry->key, GCONF_FILE_PATTERN) == 0);
-  
-  if (entry->value == NULL) {
-    value = g_strdup (file_patterns[0].pattern);
-  } else if (entry->value->type == GCONF_VALUE_STRING) {
-    value = g_strdup (gconf_value_get_string (entry->value));
-  } else
-    return;
+
+  g_return_if_fail (strcmp (key, SJ_SETTINGS_FILE_PATTERN) == 0);
+ 
+  value = g_settings_get_string (settings, key);
   while (file_patterns[i].pattern && strcmp(file_patterns[i].pattern, value) != 0) {
     i++;
   }
@@ -329,50 +340,51 @@ static void file_pattern_changed_cb (GConfClient *client, guint cnxn_id, GConfEn
 }
 
 /**
- * Default device changed (either GConf key or the widget)
+ * Default device changed (either GSettings key or the widget)
  */
-static void device_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void device_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
-  g_return_if_fail (strcmp (entry->key, GCONF_DEVICE) == 0);
-
-  if (entry->value == NULL)
-    return;
+  BraseroDrive *drive;
+  BraseroMediumMonitor *monitor;
+  char *value;
 
-  if (entry->value->type == GCONF_VALUE_STRING) {
-    BraseroDrive *drive;
-    BraseroMediumMonitor *monitor;
+  g_return_if_fail (strcmp (key, SJ_SETTINGS_DEVICE) == 0);
 
+  value = g_settings_get_string (settings, key);
+  if ((value != NULL) && (*value != '\0')) {
     monitor = brasero_medium_monitor_get_default ();
-    drive = brasero_medium_monitor_get_drive (monitor, gconf_value_get_string (entry->value));
+    drive = brasero_medium_monitor_get_drive (monitor, value);
     brasero_drive_selection_set_active (BRASERO_DRIVE_SELECTION (cd_option), drive);
     g_object_unref (drive);
     g_object_unref (monitor);
+  } else {
+    /* FIXME: see the FIXME in sj-main.c around one of the
+     * device_changed_cb calls for a way to fix this
+     */
+    g_warn_if_reached();
   }
+  g_free (value);
 }
 
 static void prefs_drive_changed (BraseroDriveSelection *selection, BraseroDrive *drive, gpointer user_data)
 {
   if (drive)
-    gconf_client_set_string (gconf_client, GCONF_DEVICE, brasero_drive_get_device (drive), NULL);
+    g_settings_set_string (sj_settings, SJ_SETTINGS_DEVICE, brasero_drive_get_device (drive));
   else
-    gconf_client_set_string (gconf_client, GCONF_DEVICE, NULL, NULL);
+    g_settings_set_string (sj_settings, SJ_SETTINGS_DEVICE, NULL);
 }
 
 /**
- * The GConf key for the strip characters option changed
+ * The GSettings key for the strip characters option changed
  */
-static void strip_changed_cb (GConfClient *client, guint cnxn_id, GConfEntry *entry, gpointer user_data)
+static void strip_changed_cb (GSettings *settings, gchar *key, gpointer user_data)
 {
   /* NOTE that strip_changed_cb in sj-main.c will also be called, and will also update
      the global value strip_chars - but which function will get called first?
      Make sure strip_chars is up to date BEFORE calling pattern_label_update */
-  g_return_if_fail (strcmp (entry->key, GCONF_STRIP) == 0);
+  g_return_if_fail (strcmp (key, SJ_SETTINGS_STRIP) == 0);
 
-  if (entry->value == NULL) {
-    strip_chars = FALSE;
-  } else {
-    strip_chars = gconf_value_get_bool (entry->value);
-  }
+  strip_chars = g_settings_get_boolean (settings, key);
   pattern_label_update ();
 }
 
@@ -403,6 +415,41 @@ on_response (GtkDialog *dialog, gint response, gpointer user_data)
   }
 }
 
+static GtkWidget *sj_audio_profile_chooser_new(void)
+{
+  GstEncodingTarget *target;
+  const GList *p;
+  GtkWidget *combo_box;
+  GtkCellRenderer *renderer;
+  GtkTreeModel *model;
+
+  model = GTK_TREE_MODEL (gtk_tree_store_new (3, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_POINTER));
+
+  target = rb_gst_get_default_encoding_target ();
+  for (p = gst_encoding_target_get_profiles (target); p != NULL; p = p->next) {
+    GstEncodingProfile *profile = GST_ENCODING_PROFILE (p->data);
+    char *media_type;
+
+    media_type = rb_gst_encoding_profile_get_media_type (profile);
+    if (media_type == NULL) {
+      continue;
+    }
+    gtk_tree_store_insert_with_values (GTK_TREE_STORE (model),
+                                       NULL, NULL, -1,
+                                       0, media_type,
+                                       1, gst_encoding_profile_get_description (profile),
+                                       2, profile, -1);
+    g_free (media_type);
+  }
+
+  combo_box = gtk_combo_box_new_with_model (model);
+  renderer = gtk_cell_renderer_text_new ();
+  gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (combo_box), renderer, TRUE);
+  gtk_cell_layout_set_attributes (GTK_CELL_LAYOUT (combo_box), renderer, "text", 1, NULL);
+
+  return GTK_WIDGET (combo_box);
+}
+
 /**
  * Clicked on Preferences in the UI
  */
@@ -417,7 +464,6 @@ G_MODULE_EXPORT void on_edit_preferences_cb (GtkMenuItem *item, gpointer user_da
     guint i;
     GtkSizeGroup *group;
     GtkWidget    *box;
-    GConfBridge *bridge = gconf_bridge_get ();
 
     prefs_dialog = GET_WIDGET ("prefs_dialog");
     box          = GET_WIDGET ("hack_hbox");
@@ -449,11 +495,11 @@ G_MODULE_EXPORT void on_edit_preferences_cb (GtkMenuItem *item, gpointer user_da
      * 	      using GtkBuilder. */
     audio_profile      = GET_WIDGET ("audio_profile");
 #else
-    audio_profile = gm_audio_profile_choose_new();
+    audio_profile = sj_audio_profile_chooser_new();
     g_signal_connect (G_OBJECT (audio_profile), "changed",
                       G_CALLBACK (prefs_profile_changed), NULL);
-	gtk_box_pack_start (GTK_BOX (box), audio_profile, TRUE, TRUE, 0);
-	gtk_widget_show (audio_profile);
+    gtk_box_pack_start (GTK_BOX (box), audio_profile, TRUE, TRUE, 0);
+    gtk_widget_show (audio_profile);
 #endif
     check_strip        = GET_WIDGET ("check_strip");
     check_eject        = GET_WIDGET ("check_eject");
@@ -468,24 +514,30 @@ G_MODULE_EXPORT void on_edit_preferences_cb (GtkMenuItem *item, gpointer user_da
 
     g_signal_connect (cd_option, "drive-changed", G_CALLBACK (prefs_drive_changed), NULL);
 
-    /* Connect to GConf to update the UI */
-    gconf_bridge_bind_property (bridge, GCONF_EJECT, G_OBJECT (check_eject), "active");
-    gconf_bridge_bind_property (bridge, GCONF_OPEN, G_OBJECT (check_open), "active");
-    gconf_bridge_bind_property (bridge, GCONF_STRIP, G_OBJECT (check_strip), "active");
-    gconf_client_notify_add (gconf_client, GCONF_DEVICE, device_changed_cb, NULL, NULL, NULL);
-    gconf_client_notify_add (gconf_client, GCONF_BASEURI, baseuri_changed_cb, NULL, NULL, NULL);
-    gconf_client_notify_add (gconf_client, GCONF_AUDIO_PROFILE, audio_profile_changed_cb, NULL, NULL, NULL);
-    gconf_client_notify_add (gconf_client, GCONF_PATH_PATTERN, path_pattern_changed_cb, NULL, NULL, NULL);
-    gconf_client_notify_add (gconf_client, GCONF_FILE_PATTERN, file_pattern_changed_cb, NULL, NULL, NULL);
-    gconf_client_notify_add (gconf_client, GCONF_STRIP, strip_changed_cb, NULL, NULL, NULL);
+    /* Connect to GSettings to update the UI */
+    g_settings_bind (sj_settings, SJ_SETTINGS_EJECT, G_OBJECT (check_eject), "active", G_SETTINGS_BIND_DEFAULT);
+    g_settings_bind (sj_settings, SJ_SETTINGS_OPEN, G_OBJECT (check_open), "active", G_SETTINGS_BIND_DEFAULT);
+    g_settings_bind (sj_settings, SJ_SETTINGS_STRIP, G_OBJECT (check_strip), "active", G_SETTINGS_BIND_DEFAULT);
+    g_signal_connect (G_OBJECT (sj_settings), "changed::"SJ_SETTINGS_DEVICE,
+                      (GCallback)device_changed_cb, NULL);
+    g_signal_connect (G_OBJECT (sj_settings), "changed::"SJ_SETTINGS_BASEURI,
+                      (GCallback)baseuri_changed_cb, NULL);
+    g_signal_connect (G_OBJECT (sj_settings), "changed::"SJ_SETTINGS_AUDIO_PROFILE,
+                      (GCallback)audio_profile_changed_cb, NULL);
+    g_signal_connect (G_OBJECT (sj_settings), "changed::"SJ_SETTINGS_PATH_PATTERN,
+                      (GCallback)path_pattern_changed_cb, NULL);
+    g_signal_connect (G_OBJECT (sj_settings), "changed::"SJ_SETTINGS_FILE_PATTERN,
+                      (GCallback)file_pattern_changed_cb, NULL);
+    g_signal_connect (G_OBJECT (sj_settings), "changed::"SJ_SETTINGS_STRIP,
+                      (GCallback)strip_changed_cb, NULL);
 
     g_signal_connect (extractor, "notify::profile", pattern_label_update, NULL);
 
-    baseuri_changed_cb (gconf_client, -1, gconf_client_get_entry (gconf_client, GCONF_BASEURI, NULL, TRUE, NULL), NULL);
-    audio_profile_changed_cb (gconf_client, -1, gconf_client_get_entry (gconf_client, GCONF_AUDIO_PROFILE, NULL, TRUE, NULL), NULL);
-    file_pattern_changed_cb (gconf_client, -1, gconf_client_get_entry (gconf_client, GCONF_FILE_PATTERN, NULL, TRUE, NULL), NULL);
-    path_pattern_changed_cb (gconf_client, -1, gconf_client_get_entry (gconf_client, GCONF_PATH_PATTERN, NULL, TRUE, NULL), NULL);
-    device_changed_cb (gconf_client, -1, gconf_client_get_entry (gconf_client, GCONF_DEVICE, NULL, TRUE, NULL), NULL);
+    baseuri_changed_cb (sj_settings, SJ_SETTINGS_BASEURI, NULL);
+    audio_profile_changed_cb (sj_settings, SJ_SETTINGS_AUDIO_PROFILE, NULL);
+    file_pattern_changed_cb (sj_settings, SJ_SETTINGS_FILE_PATTERN, NULL);
+    path_pattern_changed_cb (sj_settings, SJ_SETTINGS_PATH_PATTERN, NULL);
+    device_changed_cb (sj_settings, SJ_SETTINGS_DEVICE, NULL);
 
     g_signal_connect (GTK_DIALOG (prefs_dialog), "response", G_CALLBACK (on_response), NULL);
 
diff --git a/src/sound-juicer.h b/src/sound-juicer.h
index 2200fd0..91be42e 100644
--- a/src/sound-juicer.h
+++ b/src/sound-juicer.h
@@ -25,15 +25,14 @@
 
 #include <glib/gi18n.h>
 #include <brasero-medium-selection.h>
-#include <gconf/gconf-client.h>
 #include <gio/gio.h>
 #include <gtk/gtk.h>
 #include "sj-extractor.h"
 
 /**
- * A GConf client
+ * A GSettings object
  */
-extern GConfClient *gconf_client;
+extern GSettings *sj_settings;
 
 /**
  * The main window
@@ -102,12 +101,12 @@ extern GFile *base_uri;
 /**
  * The pattern to expand when naming folders
  */
-extern const char *path_pattern;
+extern char *path_pattern;
 
 /**
  * The pattern to expand when naming files
  */
-extern const char *file_pattern;
+extern char *file_pattern;
 
 /**
  * If file names should be shell-friendly (i.e no [ /&*?\] characters
@@ -140,27 +139,24 @@ extern GtkCellRenderer *toggle_renderer, *title_renderer, *artist_renderer;
 void sj_debug (SjDebugDomain domain, const gchar* format, ...);
 
 /**
- * GConf key names
- */
-#define GCONF_ROOT "/apps/sound-juicer"
-#define GCONF_DEVICE GCONF_ROOT "/device"
-#define GCONF_EJECT GCONF_ROOT "/eject"
-#define GCONF_OPEN GCONF_ROOT "/open_completed"
-#define GCONF_BASEPATH GCONF_ROOT "/base_path"
-#define GCONF_BASEURI GCONF_ROOT "/base_uri"
-#define GCONF_FILE_PATTERN GCONF_ROOT "/file_pattern"
-#define GCONF_PATH_PATTERN GCONF_ROOT "/path_pattern"
-#define GCONF_AUDIO_PROFILE GCONF_ROOT "/audio_profile"
-#define GCONF_PARANOIA GCONF_ROOT "/paranoia"
-#define GCONF_STRIP GCONF_ROOT "/strip-special"
-#define GCONF_WINDOW GCONF_ROOT "/window"
-#define GCONF_AUDIO_VOLUME GCONF_ROOT "/volume"
-
-#define GCONF_PROXY_ROOT "/system/http_proxy"
-#define GCONF_HTTP_PROXY_ENABLE GCONF_PROXY_ROOT "/use_http_proxy"
-#define GCONF_HTTP_PROXY GCONF_PROXY_ROOT "/host"
-#define GCONF_HTTP_PROXY_PORT GCONF_PROXY_ROOT "/port"
-
+ * GSettings key names
+ */
+#define SJ_SETTINGS_DEVICE "device"
+#define SJ_SETTINGS_EJECT "eject"
+#define SJ_SETTINGS_OPEN "open-completed"
+#define SJ_SETTINGS_BASEPATH "base-path"
+#define SJ_SETTINGS_BASEURI "base-uri"
+#define SJ_SETTINGS_FILE_PATTERN "file-pattern"
+#define SJ_SETTINGS_PATH_PATTERN "path-pattern"
+#define SJ_SETTINGS_AUDIO_PROFILE "audio-profile"
+#define SJ_SETTINGS_PARANOIA "paranoia"
+#define SJ_SETTINGS_STRIP "strip-special"
+#define SJ_SETTINGS_WINDOW "window"
+#define SJ_SETTINGS_AUDIO_VOLUME "volume"
+
+#define SJ_SETTINGS_HTTP_PROXY_ENABLE "enabled"
+#define SJ_SETTINGS_HTTP_PROXY "host"
+#define SJ_SETTINGS_HTTP_PROXY_PORT "port"
 /**
  * Custom stock icons
  */
diff --git a/tests/Makefile.am b/tests/Makefile.am
index 27906b2..0321975 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -13,7 +13,6 @@ mb_test_CPPFLAGS = \
 mb_test_CFLAGS = \
 	$(WARN_CFLAGS) \
 	$(GSTREAMER_CFLAGS) \
-	$(MEDIA_PROFILES_CFLAGS) \
 	$(BURN_CFLAGS) \
 	$(UI_CFLAGS) \
 	$(DBUS_CFLAGS) \
diff --git a/tests/mb-test.c b/tests/mb-test.c
index 9734136..c6b09cc 100644
--- a/tests/mb-test.c
+++ b/tests/mb-test.c
@@ -1,14 +1,11 @@
 #include "config.h"
 #include <glib.h>
-#include <gconf/gconf-client.h>
 #include <dbus/dbus.h>
 #include <stdlib.h>
 #include "sj-structures.h"
 #include "sj-metadata.h"
 #include "sj-metadata-getter.h"
 
-#define GCONF_ROOT "/apps/sound-juicer"
-
 static const char *
 source_to_str (MetadataSource source)
 {
@@ -92,7 +89,6 @@ int main (int argc, char** argv)
 {
   SjMetadataGetter *metadata;
   GMainLoop *loop;
-  GConfClient *gconf_client;
   GError *error = NULL;
 
   dbus_threads_init_default ();
@@ -100,13 +96,6 @@ int main (int argc, char** argv)
   g_type_init ();
   g_thread_init (NULL);
 
-  gconf_client = gconf_client_get_default ();
-  if (gconf_client == NULL) {
-    g_warning ("Could not create GConf client.\n");
-    exit (1);
-  }
-  gconf_client_add_dir (gconf_client, GCONF_ROOT, GCONF_CLIENT_PRELOAD_RECURSIVE, NULL);
-  
   metadata = sj_metadata_getter_new ();
 
   if (argc == 2) {
